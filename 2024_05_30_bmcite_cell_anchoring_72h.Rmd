---
title: "697_B-ALL+CAR_timecourse_72h"
output: html_document
date: "2024_05_30"
author: "Tian Liu"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Import Libraries

```{r}
script.date = "2024_05_30"

folder.name = "697_B-ALL+CAR_timecourse_72h"

set.seed(123)

if(!exists(folder.name)){
  dir.create(folder.name, recursive = TRUE)
}

save_point = paste0(folder.name, "/SAVE_POINT")

library(tidyverse)
library(symphony)
library(ggpubr)
library(patchwork)
library(BoneMarrowMap)
library(SeuratWrappers)
library(SingleCellExperiment)
library(ComplexHeatmap)
library(circlize)
library(Seurat)
library(SeuratData)
library(SeuratObject)
library(ggplot2)
library(RColorBrewer)
library(dittoSeq)
library(plotly)
library(htmlwidgets)
library(dplyr)
library(clusterProfiler)
library(org.Hs.eg.db)
library(msigdbr)
library(fgsea)
library(Rcpp)
library(harmony)
library(rlang)
library(scater)
library(readxl)
library(stringr)
library(SeuratExtend)
library(randomcoloR)
library(SCpubr)
library(khroma)

# Rise memory
options(future.globals.maxSize = 14000 * 1024^2) ## 14 GB
```

# 1. HTO Identification Results

## Task 1.1 Merge all samples

```{r}
# Gene Expression: This data matrix includes the gene expression counts per cell. It is the primary data used for most single-cell RNA-seq analyses, including cell type identification, differential expression analysis, clustering, and visualization (like UMAP).

# Multiplexing Capture: This generally refers to data generated from CITE-seq or Feature Barcoding technology, where antibodies tagged with oligonucleotides are used to capture protein expression. This data can be used to enrich the analysis by providing both gene and protein expression levels from the same cells. These measurements are highly useful for validating gene expression-based findings or for providing additional layers of data that might not be captured through RNA sequencing alone, such as post-translational modifications or actual protein levels.

# However, the protein data (from "Multiplexing Capture") is generally more sparse and less complex than gene expression data, which may affect some of the downstream analyses like dimension reduction and clustering. Certain steps, especially normalization and variable feature selection, might need to be adjusted due to the different data distribution.
```

```{r}
# Merge 72h samples only

sample_names <- c(
  "Pool3_Mock_1_16_72h_C1",
  "Pool3_Mock_1_16_72h_C2",
  "Pool3_Mock_1_16_72h_C3",
  "Pool3_Mock_1_16_72h_C4",
  "Pool6_CAR_1_16_72h_F1",
  "Pool6_CAR_1_16_72h_F2",
  "Pool6_CAR_1_16_72h_F3",
  "Pool6_CAR_1_16_72h_F4"
)

# Create Seurat objects for the first dataset separately
first_sample <- sample_names[1]
first_file_path <- paste0("../cellranger_multi_results_scRNAseq_697_B-ALL_resequenced/", first_sample, "/sample_filtered_feature_bc_matrix.h5")
first_data <- Read10X_h5(filename = first_file_path)
first_seurat_obj <- CreateSeuratObject(counts = first_data$`Gene Expression`, project = first_sample)
first_seurat_obj[['CMO']] = CreateAssayObject(counts = first_data$`Multiplexing Capture`)


# Create Seurat objects for the rest of the datasets
other_samples <- sample_names[-1]
seurat_objects <- list(first_seurat_obj)

# Loop through each other dataset name
for (sample_name in other_samples) {
  # Construct the file path
  file_path <- paste0("../cellranger_multi_results_scRNAseq_697_B-ALL_resequenced/", sample_name, "/sample_filtered_feature_bc_matrix.h5")
  
  # Read the data
  data <- Read10X_h5(filename = file_path)
  
  # Create a Seurat object
  seurat_obj <- CreateSeuratObject(counts = data$`Gene Expression`, project = sample_name)
  seurat_obj[['CMO']] = CreateAssayObject(counts = data$`Multiplexing Capture`)
  
  # Store the Seurat object in the list
  seurat_objects[[sample_name]] <- seurat_obj
}

# Merge the Seurat objects
B_ALL_CAR.Object <- merge(x = first_seurat_obj, y = seurat_objects[-1], add.cell.id = sample_names)
```

```{r}
B_ALL_CAR.Object@assays
# rownames(B_ALL_CAR.Object@assays[["RNA"]])
```

```{r}
B_ALL_CAR.Object@meta.data
```

```{r}
# Add Metadata
# Compute Num of gene per UMI

B_ALL_CAR.Object$log10GenePerUMI = log10(B_ALL_CAR.Object$nFeature_RNA) / log10(B_ALL_CAR.Object$nCount_RNA)
```

```{r}
# Compute Percent mito ratio

B_ALL_CAR.Object$mitoPct = PercentageFeatureSet(B_ALL_CAR.Object, pattern = "^MT-")
B_ALL_CAR.Object$mitoRatio = B_ALL_CAR.Object@meta.data$mitoPct / 100
```

```{r}
B_ALL_CAR.Object@meta.data

# View(B_ALL_CAR.Object@meta.data)

```

# 2. Celltype Anchoring

```{r}
Task2_UMAP_before_filtering <- paste0(folder.name, "/Task2_UMAP_before_filtering_72h")

if(!exists(Task2_UMAP_before_filtering)){
  dir.create(Task2_UMAP_before_filtering)
}
```

## Task 2.1 Add New Label Name

```{r}
# Define the mapping between old labels and new labels
mapping <- c(
  "Pool3_Mock_1_16_72h_C1" = "WT_WT_Mock_72",
  "Pool3_Mock_1_16_72h_C2" = "WT_KO_Mock_72",
  "Pool3_Mock_1_16_72h_C3" = "KO_WT_Mock_72",
  "Pool3_Mock_1_16_72h_C4" = "KO_KO_Mock_72",
  "Pool6_CAR_1_16_72h_F1" = "WT_WT_CAR_72",
  "Pool6_CAR_1_16_72h_F2" = "WT_KO_CAR_72",
  "Pool6_CAR_1_16_72h_F3" = "KO_WT_CAR_72",
  "Pool6_CAR_1_16_72h_F4" = "KO_KO_CAR_72"
)

# Apply the mapping to create the new_labels column in B_ALL_CAR.Object@meta.data
B_ALL_CAR.Object@meta.data$new_labels <- mapping[B_ALL_CAR.Object@meta.data$orig.ident]

# Move new_labels column right after orig.ident
B_ALL_CAR.Object@meta.data <- B_ALL_CAR.Object@meta.data[, c(1, ncol(B_ALL_CAR.Object@meta.data), 2:(ncol(B_ALL_CAR.Object@meta.data)-1))]

# Check for unmapped values in B_ALL_CAR.Object@meta.data
unmapped <- is.na(B_ALL_CAR.Object@meta.data$new_labels)
if (any(unmapped)) {
  cat("The following orig.ident values have no mapping and are set to NA:\n")
  cat(paste(B_ALL_CAR.Object@meta.data$orig.ident[unmapped], collapse = "\n"))
  # Optionally set a default value for unmapped entries
  # B_ALL_CAR.Object@meta.data$new_labels[unmapped] <- "DefaultValue"
}

B_ALL_CAR.Object@meta.data
```

# SAVE POINT

```{r}
save_point = paste0(folder.name, "/SAVE_POINT")

if(!exists(save_point)){
  dir.create(save_point, recursive = TRUE)
}
```

```{r}
saveRDS(B_ALL_CAR.Object, file = paste0(save_point, "/B_ALL_CAR.Object_new_labels_only_72h_SeuratV5.rds"))
```

```{r}
# B_ALL_CAR.Object <- readRDS(paste0(save_point, "/B_ALL_CAR.Object_new_labels_only_72h_SeuratV5.rds"))
```

## Task 2.2 Produce a UMAP without a reference - new_labels

### Task 2.2.1 PCA

```{r}
# Use standard normalization

DefaultAssay(B_ALL_CAR.Object) <- 'RNA'
B_ALL_CAR.Object <- NormalizeData(B_ALL_CAR.Object) %>% 
  # FindVariableFeatures() can find 'variable features', genes that exhibit high variability in expression levels across different cells
  FindVariableFeatures() %>% 
  ScaleData() %>% 
  RunPCA()
```

```{r}
# Determine percent of variation associated with each PC
pct <- B_ALL_CAR.Object[["pca"]]@stdev / sum(B_ALL_CAR.Object[["pca"]]@stdev) * 100
# pct

# Calculate cumulative percents for each PC
cumu <- cumsum(pct)
# cumu

# Determine which PC exhibits cumulative percent greater than 90% and % variation associated with the PC as less than 5
co1 <- which(cumu > 90 & pct < 5)[1]
co1
```

```{r}
# Identifies the PC where the percent change in variation between consecutive PCs is less than 0.1%
co2 <- sort(which((pct[1:length(pct) - 1] - pct[2:length(pct)]) > 0.1), decreasing = T)[1] + 1
co2
```

```{r}
# Choose the minimum of these two metrics as the PCs covering the majority of the variation in the data.
pcs <- min(co1, co2)
pcs
```

```{r}
plot_df <- data.frame(pct = pct,
                      cumu = cumu,
                      rank = 1:length(pct))

plot_df

ggplot(plot_df, aes(cumu, pct, label = rank, color = rank > pcs)) +
  geom_text() +
  # geom_vline(xintercept = 75, color = "grey") +
  # geom_hline(yintercept = min(pct[pct > 5]), color = "grey") +
  theme_bw()

```

### Task 2.2.2 RunUMAP by Default

```{r}
# Default resolution: 0.8
B_ALL_CAR.Object <- B_ALL_CAR.Object %>%
  FindNeighbors(., dims = 1:pcs) %>%
  # Enable method = "igraph" to avoid casting large data to a dense matrix.
  FindClusters(., method = "igraph") %>%
  RunUMAP(.,
          dims = 1:40,
          # dims = 1:pcs,
          reduction = "pca",
          n.components = 3L)
``` 

```{r}
head(B_ALL_CAR.Object@meta.data)
```

### Task 2.2.3 UMAP Plot - new_labels

```{r}
Task2.2_UMAP <- paste0(Task2_UMAP_before_filtering, "/Task2.2_UMAP_with_new_labels")
  
if(!exists(Task2.2_UMAP)){
  dir.create(Task2.2_UMAP)
}
```

```{r}
B_ALL_CAR.Object@meta.data

B_ALL_CAR.Object@meta.data %>%
    dplyr::count(new_labels)
```

```{r}
num_unique_labels <- B_ALL_CAR.Object@meta.data %>%
    summarize(num_labels = n_distinct(new_labels)) %>%
    pull(num_labels)

print(num_unique_labels)
```

```{r}
# Task 2.2.3.1 Generate Distinct Colors

sample_colors <- c( 
  "#000075","#004DFF","dodgerblue2","steelblue4",
  "#E31A1C","maroon","deeppink1",
  "green4","green1","#00FFFF",
  "#8200FF",
  "#FF7F00","gold1","#FFFF00",
  "gray70","#F0B98D"
)
# sample_colors <- c( 
#   "#000075","#004DFF","dodgerblue2","steelblue4", "#00B7FF",
#   "#E31A1C","maroon","#C20078","deeppink1",
#   "green4","green1","#00FFFF","#BBFF00",
#   "#6A3D9A","#8200FF",
#   "#FF7F00","gold1","#FFFF00",
#   "gray70","#F0B98D"
# )
sample_labels <- levels(as.factor(B_ALL_CAR.Object@meta.data$new_labels))
sample_colors <- setNames(sample_colors, sample_labels)
```

```{r}
#### Task 2.2.3.2 2D Plot -- new_labels 

set.seed(123)  # Set a seed for reproducibility

plot <- dittoDimPlot(B_ALL_CAR.Object,
             var = "new_labels",
             color.panel = sample_colors,  # Use our custom colors
             size = 0.4,
             # legend.show = FALSE,
             legend.size = 5,
             do.label = TRUE,
             opacity = 0.5,
             labels.size = 1.5,
             reduction.use = "umap",
             xlab = "UMAP 1",
             ylab = "UMAP 2",
             main = "UMAP for 72h Samples"
             )

# Modify the plot to change legend text size
plot <- plot + theme(legend.position = "bottom",
                     legend.text = element_text(size = 8),
                     legend.spacing.x = unit(1, 'cm'), # Adjust spacing
                     legend.spacing.y = unit(1, 'cm')) 

ggsave(filename = paste0(Task2.2_UMAP, "/2D_UMAP_with_new_labels_72h.pdf"), 
       plot = plot, 
       width = 10,  
       height = 8)
```

```{r}
#### Task 2.2.3.3 Interactive Plot -- new_labels

# Extract UMAP data
umap_data <- Embeddings(B_ALL_CAR.Object, reduction = "umap")
# Extract metadata for hover information
# umap_metadata <- FetchData(B_ALL_CAR.Object, vars = c("new_labels", "predicted.id"))
umap_metadata <- FetchData(B_ALL_CAR.Object, vars = "new_labels")
# Combine UMAP data with metadata
umap_plot_data <- cbind(umap_data, umap_metadata)

umap_plot_data$new_labels <- as.factor(umap_plot_data$new_labels)
# umap_plot_data$predicted.id <- as.factor(umap_plot_data$predicted.id)
umap_plot_data_df <- as.data.frame(umap_plot_data)
```

```{r}
# Create an interactive plot
fig <- plot_ly(umap_plot_data_df, 
               x = ~umap_1, 
               y = ~umap_2, 
               type = 'scatter', 
               mode = 'markers',
               color = ~new_labels,
               colors = sample_colors,
               marker = list(size = 3, opacity = 0.5),               
               text = ~paste("Label:", new_labels),
               hoverinfo = 'text')

# Customize the layout
fig <- fig %>% layout(title = 'Interactive UMAP Plot for 72h Samples',
                      xaxis = list(title = 'UMAP 1'),
                      yaxis = list(title = 'UMAP 2'),
                      legend = list(font = list(size = 12)))

saveWidget(fig, file = paste0(Task2.2_UMAP, "/Interactive_UMAP_with_new_labels_72h.html"))
```

```{r}
#### Task 2.2.3.4 3D Plot -- new_labels

# Embeddings(object = B_ALL_CAR.Object, reduction = "umap")

UMAP.3D <-
  plot_ly(data = umap_plot_data_df,
    x = ~umap_1,
    y = ~umap_2,
    z = ~umap_3,
    color = ~new_labels,
    colors = sample_colors,
    type="scatter3d",
    mode="markers+text",
    marker = list(
    size = 2,  # Slightly larger markers
    opacity = 0.5  # Some transparency
  )
)

htmlwidgets::saveWidget(
  widget = UMAP.3D,
  file = paste0(Task2.2_UMAP, "/3D_UMAP_with_new_labels_72h.html"),
  selfcontained = T,
  title = "3D UMAP for 72h Samples"
)
```

## Task 2.3 Feature UMAP

```{r}
Task2.3_FeatureUMAP <- paste0(Task2_UMAP_before_filtering, "/Task2.3_FeatureUMAP")
  
if(!exists(Task2.3_FeatureUMAP)){
  dir.create(Task2.3_FeatureUMAP)
}
```

```{r}
genes <- c("CD19", "PAX5", "CD3D")

for (gene in genes) {
  pdf(paste0(Task2.3_FeatureUMAP, "/", gene, "_with_cutoff.pdf")) 
  p <- FeaturePlot(
    object = B_ALL_CAR.Object,
    features = gene,
    min.cutoff = "q10",  
    max.cutoff = "q90"   
  )
  print(p) 
  dev.off()
  print(p) 
}
```

## Task 2.4 Split into Individual Samples

```{r}
Task2.4_indUMAP <- paste0(Task2_UMAP_before_filtering, "/Task2.4_Individual_Sample_UMAP")
  
if(!exists(Task2.4_indUMAP)){
  dir.create(Task2.4_indUMAP)
}
```

```{r}
unique_labels <- unique(B_ALL_CAR.Object@meta.data$new_labels)

# # Store plot objects in a list
# plot_list <- list()

for (label in unique_labels) {
  # Extract data for plotting
  data <- FetchData(B_ALL_CAR.Object, vars = c("umap_1", "umap_2", "new_labels"))

  # Define the highlight condition directly in the data frame
  data$highlight <- ifelse(data$new_labels == label, 'highlighted', 'other')

  # Start a ggplot
  p <- ggplot(data, aes(x = umap_1, y = umap_2)) +
    geom_point(data = data[data$highlight == "other", ], aes(color = highlight), alpha = 0.5, size = 0.2) +
    geom_point(data = data[data$highlight == "highlighted", ], aes(color = highlight), size = 0.2) +
    scale_color_manual(values = c("other" = "grey", "highlighted" = "red")) +
    ggtitle(paste("UMAP Plot for", label)) +
    theme_minimal()

  pdf_filename <- paste0(Task2.4_indUMAP, "/UMAP_highlight_", label, ".pdf")
  
  pdf(pdf_filename, width = 8, height = 6)
  print(p)
  dev.off()
  
  # plot_list[[label]] <- p
}
```

```{r}
# # Split the Seurat object based on 'new_labels'
# split_objects <- SplitObject(B_ALL_CAR.Object, split.by = "new_labels")
# 
# # Loop through each subset, plot UMAP, and save as PDF
# for (label in names(split_objects)) {
#   # Generate the UMAP plot
#   p <- DimPlot(split_objects[[label]], reduction = "umap")
# 
#   file_path <- paste0(Task2.4_indUMAP, "/", label, "_UMAP.pdf")
#   
#   pdf(file_path)
#   print(p)  
#   dev.off() 
# }
```

## Task 2.5 bmcite Cell Annotation

```{r}
### Load Reference bmcite


# SeuratData::InstallData("bmcite")
bm <- LoadData(ds = "bmcite")
bm
```

```{r}
# The reference dataset contains a WNN graph, reflecting a weighted combination of the RNA and protein data in this CITE-seq experiment.

# We can compute a UMAP visualization based on this graph. We set return.model = TRUE, which will enable us to project query datasets onto this visualization.

bm <- RunUMAP(bm, nn.name = "weighted.nn", reduction.name = "wnn.umap", 
              reduction.key = "wnnUMAP_", return.model = TRUE)
DimPlot(bm, group.by = "celltype.l2", reduction = "wnn.umap") 
```

```{r}
## Compute an sPCA transformation


# As described in our manuscript, we first compute a ‘supervised’ PCA. This identifies the transformation of the transcriptome data that best encapsulates the structure of the WNN graph. This allows a weighted combination of the protein and RNA measurements to ‘supervise’ the PCA, and highlight the most relevant sources of variation. After computing this transformation, we can project it onto a query dataset. We can also compute and project a PCA projection, but recommend the use of sPCA when working with multimodal references that have been constructed with WNN analysis.

# The sPCA calculation is performed once, and then can be rapidly projected onto each query dataset.

bm <- ScaleData(bm, assay = 'RNA')
bm <- RunSPCA(bm, assay = 'RNA', graph = 'wsnn')
```

```{r}
## Compute a cached neighbor index


# Since we will be mapping multiple query samples to the same reference, we can cache particular steps that only involve the reference. This step is optional but will improve speed when mapping multiple samples.

# We compute the first 50 neighbors in the sPCA space of the reference. We store this information in the spca.annoy.neighbors object within the reference Seurat object and also cache the annoy index data structure (via cache.index = TRUE).

bm <- FindNeighbors(
  object = bm,
  reduction = "spca",
  dims = 1:50,
  graph.name = "spca.annoy.neighbors", 
  k.param = 50,
  cache.index = TRUE,
  return.neighbor = TRUE,
  l2.norm = TRUE
)
```

```{r}
## Query dataset preprocessing


# Here we will demonstrate mapping multiple donor bone marrow samples to the multimodal bone marrow reference. 
# We first split the data back into separate Seurat objects, one for each original donor to map individually.

# Batch Effects and Variability: Each donor's sample can have unique biological characteristics and technical variations. Now, you can address these variations more effectively.

B_ALL_CAR.Object.batches <- SplitObject(B_ALL_CAR.Object, split.by = "new_labels")
# B_ALL_CAR.Object.batches
```

```{r}
# We then normalize the query in the same manner as the reference. Here, the reference was normalized using log-normalization via NormalizeData(). If the reference had been normalized using SCTransform(), the query must be normalized with SCTransform() as well.

B_ALL_CAR.Object.batches <- lapply(X = B_ALL_CAR.Object.batches, FUN = NormalizeData, verbose = FALSE)
```

```{r}
## Mapping - Celltype Identification


# We then find anchors between each donor query dataset and the multimodal reference. This command is optimized to minimize mapping time, by passing in a pre-computed set of reference neighbors, and turning off anchor filtration.

anchors <- list()
for (i in 1:length(B_ALL_CAR.Object.batches)) {
  anchors[[i]] <- FindTransferAnchors(
    reference = bm,
    query = B_ALL_CAR.Object.batches[[i]],
    k.filter = NA,
    reference.reduction = "spca", 
    reference.neighbors = "spca.annoy.neighbors", 
    dims = 1:50
  )
}
```

```{r}
# We then individually map each of the datasets.

for (i in 1:length(B_ALL_CAR.Object.batches)) {
  B_ALL_CAR.Object.batches[[i]] <- MapQuery(
    anchorset = anchors[[i]], 
    query = B_ALL_CAR.Object.batches[[i]],
    reference = bm, 
    refdata = list(
      celltype = "celltype.l2", 
      predicted_ADT = "ADT"),
    reference.reduction = "spca",
    reduction.model = "wnn.umap"
  )
}
```

```{r}
# We can also merge all the objects into one dataset. Note that they have all been integrated into a common space, defined by the reference. We can then visualize the results together.

# Merge the batches
B_ALL_CAR.Object <- merge(B_ALL_CAR.Object.batches[[1]], B_ALL_CAR.Object.batches[2:length(B_ALL_CAR.Object.batches)], merge.dr = "umap")
```

### Task 2.5.1 Overall UMAP

```{r}
Task2.5_bm_Cellbype <- paste0(Task2_UMAP_before_filtering, "/Task2.5_bm_Cellbype_UMAP")
  
if(!exists(Task2.5_bm_Cellbype)){
  dir.create(Task2.5_bm_Cellbype)
}
```

```{r}
set.seed(123)
p <- DimPlot(B_ALL_CAR.Object, reduction = "umap", group.by =  "predicted.celltype", label = TRUE, repel = TRUE, label.size = 3) 
p <- p + theme(legend.text = element_text(size = 6))
p
filename <- "overall_UMAP_with_celltype_72h.pdf"
path <- paste0(Task2.5_bm_Cellbype)
ggsave(filename = file.path(path, filename), plot = p, width = 10, height = 8)
```

```{r}
# Plot on bm-cite data

# set.seed(123)
# p <- DimPlot(B_ALL_CAR.Object, reduction = "ref.umap", group.by =  "predicted.celltype", label = TRUE, repel = TRUE, label.size = 3) 
# p <- p + theme(legend.text = element_text(size = 6))
# p
# filename <- "celltype_bmcite_ref_B_ALL_CAR_UMAP_Plot.pdf"
# path <- paste0(Task2.5_bm_Cellbype)
# ggsave(filename = file.path(path, filename), plot = p, width = 10, height = 8)
```

### Task 2.5.2 Individual UMAP with Cell Type

```{r}
Task2.5_bm_Cellbype_ind <- paste0(Task2.5_bm_Cellbype, "/Individual_Sample_UMAP_with_celltype")
  
if(!exists(Task2.5_bm_Cellbype_ind)){
  dir.create(Task2.5_bm_Cellbype_ind)
}
```

```{r}
# Get unique sample labels from new_labels
unique_labels <- unique(B_ALL_CAR.Object@meta.data$new_labels)

# Define a fixed color palette function for cell types using RColorBrewer
cell_types <- unique(B_ALL_CAR.Object@meta.data$predicted.celltype)
num_cell_types <- length(cell_types)

# Choose a palette with bright, distinct colors
getFixedColors <- function(n) {
  if (n <= 8) {
    return(brewer.pal(n, "Dark2")) # For up to 8 colors
  } else {
    return(colorRampPalette(brewer.pal(8, "Dark2"))(n)) # Extend if more colors are needed
  }
}

# Assign colors to each cell type
fixed_colors <- setNames(getFixedColors(num_cell_types), cell_types)

# Loop through each sample
for (label in unique_labels) {
  # Extract data for plotting
  data <- FetchData(B_ALL_CAR.Object, vars = c("umap_1", "umap_2", "new_labels", "predicted.celltype"))
  
  # Define the highlight condition directly in the data frame
  data$highlight <- ifelse(data$new_labels == label, 'highlighted', 'other')
  
  # Start a ggplot
  p <- ggplot() +
    # First, plot all other samples in grey
    geom_point(data = data[data$highlight == "other", ], aes(x = umap_1, y = umap_2), color = "grey", alpha = 0.3, size = 0.2) +
    # Next, plot the highlighted sample with fixed colors for different cell types
    geom_point(data = data[data$highlight == "highlighted", ], aes(x = umap_1, y = umap_2, color = predicted.celltype), size = 0.3) +
    # Use the predefined fixed colors
    scale_color_manual(values = fixed_colors) +
    ggtitle(paste("UMAP Plot Highlighting", label)) +
    theme_minimal() +
    theme(legend.title = element_text(size = 10), legend.text = element_text(size = 8))

  # Define the output filename for the current sample
  pdf_filename <- paste0(Task2.5_bm_Cellbype_ind, "/UMAP_highlight_", label, ".pdf")
  
  # Save the plot to a PDF file
  pdf(pdf_filename, width = 8, height = 6)
  print(p)
  dev.off()
}
```

```{r}
# # Only show interested samples:
# 
# library(RColorBrewer)
# 
# # Get unique sample labels from new_labels
# unique_samples <- unique(B_ALL_CAR.Object@meta.data$new_labels)
# 
# # Define a color palette function using RColorBrewer
# getDistinctColors <- function(n) {
#   if (n <= 12) {
#     return(brewer.pal(n, "Set3")) # Set3 has distinct colors
#   } else {
#     return(colorRampPalette(brewer.pal(12, "Set3"))(n))
#   }
# }
# 
# # Loop through each sample
# for (sample in unique_samples) {
#   
#   # Subset the data for the current sample
#   sample_data <- subset(B_ALL_CAR.Object, subset = new_labels == sample)
#   
#   # Extract UMAP coordinates and predicted cell types
#   data <- FetchData(sample_data, vars = c("umap_1", "umap_2", "predicted.celltype"))
#   
#   # Generate the UMAP plot for the current sample
#   p <- ggplot(data, aes(x = umap_1, y = umap_2, color = predicted.celltype)) +
#     geom_point(size = 0.2, alpha = 0.8) +
#     ggtitle(paste("UMAP Plot for Sample:", sample)) +
#     scale_color_manual(values = getDistinctColors(length(unique(data$predicted.celltype)))) +
#     theme_minimal() +
#     theme(legend.title = element_text(size = 10), legend.text = element_text(size = 8))
#   
#   # Define the output filename for the current sample
#   pdf_filename <- paste0(Task2.5_bm_Cellbype_ind, "/", "UMAP_", sample, ".pdf")
#   
#   # Save the plot to a PDF file
#   pdf(pdf_filename, width = 8, height = 6)
#   print(p)
#   dev.off()
# }
```

```{r}
# # Now that mapping is complete, we can visualize the results for individual objects
# # Split the Seurat object based on 'new_labels'
# 
# # Loop through each subset, plot UMAP, and save as PDF
# for (label in names(B_ALL_CAR.Object.batches)) {
#   # Generate the UMAP plot
#   p <- DimPlot(B_ALL_CAR.Object.batches[[label]], reduction = "umap", group.by = 'predicted.celltype', label.size = 3)
# 
#   file_path <- paste0(Task2.5_bm_Cellbype_ind, "/", label, "_UMAP.pdf")
#   
#   pdf(file_path)
#   print(p)  
#   dev.off() 
# }
```

# 3. Manually modify clusters

```{r}
Task3_UMAP_after_filter <- paste0(folder.name, "/Task3_UMAP_after_filtering_72h")

if(!exists(Task3_UMAP_after_filter)){
  dir.create(Task3_UMAP_after_filter)
}
```

## Task 3.1 For T Cell Cluster

### Task 3.1.1 Remove PAX5-expressing cells

```{r}
plot <- DimPlot(object = B_ALL_CAR.Object)
cells.located = CellSelector(plot = plot)
```

```{r}
B_ALL_CAR.Object_t_cell_cluster = B_ALL_CAR.Object[,cells.located]
```

```{r}
# B_ALL_CAR.Object_t_cell_cluster@meta.data
table(B_ALL_CAR.Object_t_cell_cluster@meta.data$predicted.celltype)
```

```{r}
pax5_positive_cells <- WhichCells(B_ALL_CAR.Object_t_cell_cluster, expression = PAX5 > 0)

# Remove PAX5-expressing cells
B_ALL_CAR.Object_t_cell_cluster.filtered <- subset(B_ALL_CAR.Object_t_cell_cluster, cells = setdiff(Cells(B_ALL_CAR.Object_t_cell_cluster), pax5_positive_cells))
```

```{r}
table(B_ALL_CAR.Object_t_cell_cluster.filtered@meta.data$predicted.celltype)
```

```{r}
set.seed(123)
p <- DimPlot(B_ALL_CAR.Object_t_cell_cluster.filtered, reduction = "umap", group.by =  "predicted.celltype", label = TRUE, repel = TRUE, label.size = 3) 
p <- p + theme(legend.text = element_text(size = 6))
p
```

### Task 3.1.2 Remove B Cells

```{r}
# Identify cells to remove based on predicted cell type
cell_types_to_remove_t <- c("Plasmablast", "Prog_B 1", "Prog_B 2", "Prog_RBC", "Prog_DC", "GMP")
cells_to_remove_t <- WhichCells(B_ALL_CAR.Object_t_cell_cluster.filtered, expression = predicted.celltype %in% cell_types_to_remove_t)

# Remove the specified cells based on cell type from the T cell cluster
B_ALL_CAR.Object_t_cell_cluster.filtered.final <- subset(B_ALL_CAR.Object_t_cell_cluster.filtered, cells = setdiff(Cells(B_ALL_CAR.Object_t_cell_cluster.filtered), cells_to_remove_t))
```

```{r}
set.seed(123)
p <- DimPlot(B_ALL_CAR.Object_t_cell_cluster.filtered.final, reduction = "umap", group.by =  "predicted.celltype", label = TRUE, repel = TRUE, label.size = 3) 
p <- p + theme(legend.text = element_text(size = 6))
p
```

### Task 3.1.3  Remove from the Original Seurat Object

```{r}
# Remove the specified cells from the original Seurat object
B_ALL_CAR.Object_t_cell_cluster.filtered.final.all <- subset(B_ALL_CAR.Object, cells = setdiff(Cells(B_ALL_CAR.Object), pax5_positive_cells))

B_ALL_CAR.Object_t_cell_cluster.filtered.final.all <- subset(B_ALL_CAR.Object_t_cell_cluster.filtered.final.all, cells = setdiff(Cells(B_ALL_CAR.Object_t_cell_cluster.filtered.final.all), cells_to_remove_t))
```

```{r}
set.seed(123)
p <- DimPlot(B_ALL_CAR.Object_t_cell_cluster.filtered.final.all, reduction = "umap", group.by =  "predicted.celltype", label = TRUE, repel = TRUE, label.size = 3) 
p <- p + theme(legend.text = element_text(size = 6))
p
```

```{r}
genes <- c("CD19", "PAX5", "CD3D")

for (gene in genes) {
  p <- FeaturePlot(
    object = B_ALL_CAR.Object_t_cell_cluster.filtered.final.all,
    features = gene,
    min.cutoff = "q10",  
    max.cutoff = "q90" 
  )
  print(p) 
}
```

## Task 3.2 For B-ALL Clusters

### Task 3.2.1 Remove CD3D-expressing cells 

```{r}
plot <- DimPlot(object = B_ALL_CAR.Object)
cells.located = CellSelector(plot = plot)
```

```{r}
B_ALL_CAR.Object_B_ALL_cluster = B_ALL_CAR.Object[,cells.located]
```

```{r}
# B_ALL_CAR.Object_B_ALL_cluster@meta.data
table(B_ALL_CAR.Object_B_ALL_cluster@meta.data$predicted.celltype)
```

```{r}
cd3d_positive_cells <- WhichCells(B_ALL_CAR.Object_B_ALL_cluster, expression = CD3D > 0)

# Remove CD3D-expressing cells
B_ALL_CAR.Object_B_ALL_cluster.filtered <- subset(B_ALL_CAR.Object_B_ALL_cluster, cells = setdiff(Cells(B_ALL_CAR.Object_B_ALL_cluster), cd3d_positive_cells))
```

```{r}
table(B_ALL_CAR.Object_B_ALL_cluster.filtered@meta.data$predicted.celltype)
```

```{r}
set.seed(123)
p <- DimPlot(B_ALL_CAR.Object_B_ALL_cluster.filtered, reduction = "umap", group.by =  "predicted.celltype", label = TRUE, repel = TRUE, label.size = 3) 
p <- p + theme(legend.text = element_text(size = 6))
p
```

### Task 3.2.2 Remove T cells from B-ALL clusters

```{r}
# Identify cells to remove based on predicted cell type
cell_types_to_remove_b <- c("CD4 Memory", "CD4 Naive", "CD8 Memory_2", "Treg")
cells_to_remove_b <- WhichCells(B_ALL_CAR.Object_B_ALL_cluster.filtered, expression = predicted.celltype %in% cell_types_to_remove_b)

# Remove the specified cells based on cell type from the T cell cluster
B_ALL_CAR.Object_B_ALL_cluster.filtered.final <- subset(B_ALL_CAR.Object_B_ALL_cluster.filtered, cells = setdiff(Cells(B_ALL_CAR.Object_B_ALL_cluster.filtered), cells_to_remove_b))
```

```{r}
set.seed(123)
p <- DimPlot(B_ALL_CAR.Object_B_ALL_cluster.filtered.final, reduction = "umap", group.by =  "predicted.celltype", label = TRUE, repel = TRUE, label.size = 3) 
p <- p + theme(legend.text = element_text(size = 6))
p
```

### Task 3.2.3 Remove from the Original Seurat Object

```{r}
# Remove the specified cells from the original Seurat object
B_ALL_CAR.Object_B_ALL_cluster.filtered.final.all <- subset(B_ALL_CAR.Object_t_cell_cluster.filtered.final.all, cells = setdiff(Cells(B_ALL_CAR.Object_t_cell_cluster.filtered.final.all), cd3d_positive_cells))

B_ALL_CAR.Object_B_ALL_cluster.filtered.final.all <- subset(B_ALL_CAR.Object_B_ALL_cluster.filtered.final.all, cells = setdiff(Cells(B_ALL_CAR.Object_B_ALL_cluster.filtered.final.all), cells_to_remove_b))
```

```{r}
B_ALL_CAR.final.all <- B_ALL_CAR.Object_B_ALL_cluster.filtered.final.all

set.seed(123)
p <- DimPlot(B_ALL_CAR.final.all, reduction = "umap", group.by =  "predicted.celltype", label = TRUE, repel = TRUE, label.size = 3) 
p <- p + theme(legend.text = element_text(size = 6))
p
```

```{r}
genes <- c("CD19", "PAX5", "CD3D")

for (gene in genes) {
  p <- FeaturePlot(
    object = B_ALL_CAR.final.all,
    features = gene,
    min.cutoff = "q10",  
    max.cutoff = "q90" 
  )
  print(p) 
}
```

## Task 3.3 Re-run UMAP

```{r}
B_ALL_CAR.final.all.rerun <- B_ALL_CAR.final.all
```

```{r}
DefaultAssay(B_ALL_CAR.final.all.rerun) <- 'RNA'
B_ALL_CAR.final.all.rerun <- NormalizeData(B_ALL_CAR.final.all.rerun) %>% 
  FindVariableFeatures() %>% 
  ScaleData() %>% 
  RunPCA()
```

```{r}
# Determine percent of variation associated with each PC
pct <- B_ALL_CAR.final.all.rerun[["pca"]]@stdev / sum(B_ALL_CAR.final.all.rerun[["pca"]]@stdev) * 100
# pct

# Calculate cumulative percents for each PC
cumu <- cumsum(pct)
# cumu

# Determine which PC exhibits cumulative percent greater than 90% and % variation associated with the PC as less than 5
co1 <- which(cumu > 90 & pct < 5)[1]
co1
```

```{r}
# Identifies the PC where the percent change in variation between consecutive PCs is less than 0.1%
co2 <- sort(which((pct[1:length(pct) - 1] - pct[2:length(pct)]) > 0.1), decreasing = T)[1] + 1
co2
```

```{r}
# Choose the minimum of these two metrics as the PCs covering the majority of the variation in the data.
pcs <- min(co1, co2)
pcs
```

```{r}
# Default resolution: 0.8
B_ALL_CAR.final.all.rerun <- B_ALL_CAR.final.all.rerun %>%
  FindNeighbors(., dims = 1:pcs) %>%
  # Enable method = "igraph" to avoid casting large data to a dense matrix.
  FindClusters(., method = "igraph") %>%
  RunUMAP(.,
          dims = 1:40,
          # dims = 1:pcs,
          reduction = "pca",
          n.components = 3L)
``` 

```{r}
# set.seed(123)
# p <- DimPlot(B_ALL_CAR.final.all.rerun, reduction = "umap", group.by =  "predicted.celltype", label = TRUE, repel = TRUE, label.size = 3) 
# p <- p + theme(legend.text = element_text(size = 6))
# p
```

# SAVE POINT

```{r}
# saveRDS(B_ALL_CAR.final.all.rerun, file = paste0(save_point, "/B_ALL_CAR.Object_with_celltype_only_72h_filtered_final_rerun_SeuratV5.rds"))
```

```{r}
B_ALL_CAR.final.all.rerun <- readRDS(paste0(save_point, "/B_ALL_CAR.Object_with_celltype_only_72h_filtered_final_rerun_SeuratV5.rds"))
```

## Task 3.4 Generate UMAPS

```{r}
B_ALL_CAR.final.all.rerun@meta.data

B_ALL_CAR.final.all.rerun@meta.data %>%
    dplyr::count(predicted.celltype)
```

```{r}
# Define a colorblind-friendly palette
colors <- colour("muted") 

celltypes <- c("CD4 Memory", "CD8 Memory_2", "GMP", "Prog_B 1", "Prog_B 2", "Prog_RBC", "Treg", "CD4 Naive", "Prog_DC")

colors_use <- setNames(colors(length(celltypes)), celltypes)

print(colors_use)
```

```{r}
#   CD4 Memory CD8 Memory_2          GMP     Prog_B 1     Prog_B 2     Prog_RBC         Treg    CD4 Naive      Prog_DC 
#    "#CC6677"    "#332288"    "#DDCC77"    "#117733"    "#88CCEE"    "#882255"    "#44AA99"    "#999933"    "#AA4499" 
# attr(,"missing")
# [1] "#DDDDDD"
```

```{r}
p <- SCpubr::do_DimPlot(sample = B_ALL_CAR.final.all.rerun,
                        plot.axes = TRUE,
                        group.by = "predicted.celltype",
                        colors.use = colors_use,
                        pt.size = 0.5,
                        legend.icon.size = 6)

p <- p + theme(legend.text = element_text(size = 6))
p <- p + ggtitle("UMAP for 72h Samples")
p
filename <- "Overall_UMAP_after_filtering_with_celltype_72h.pdf"
path <- paste0(Task3_UMAP_after_filter)
ggsave(filename = file.path(path, filename), plot = p, width = 20, height = 15)
```

```{r}
genes <- c("CD19", "PAX5", "CD3D")

for (gene in genes) {
  pdf(paste0(Task3_UMAP_after_filter, "/", gene, "_with_cutoff.pdf")) 
  p <- FeaturePlot(
    object = B_ALL_CAR.final.all.rerun,
    features = gene,
    min.cutoff = "q10",  
    max.cutoff = "q90"   
  )
  print(p) 
  dev.off()
  print(p) 
}
```

```{r}
plot <- DimPlot(object = B_ALL_CAR.final.all.rerun)
cells.located = CellSelector(plot = plot)
```

```{r}
seurat_object_t = B_ALL_CAR.final.all.rerun[,cells.located]
```

```{r}
p <- SCpubr::do_DimPlot(sample = seurat_object_t,
                        plot.axes = TRUE,
                        group.by = "predicted.celltype",
                        colors.use = colors_use,
                        pt.size = 0.5)

p <- p + theme(legend.text = element_text(size = 6))
p <- p + ggtitle("UMAP of T-Cell Clusters Predicted Cell Types - 72h Samples")
p
filename <- "UMAP_T-Cell_Cluster_after_filtering_with_celltype.pdf"
path <- paste0(Task3_UMAP_after_filter)
ggsave(filename = file.path(path, filename), plot = p, width = 10, height = 8)
```


```{r}
plot <- DimPlot(object = B_ALL_CAR.final.all.rerun)
cells.located = CellSelector(plot = plot)
```

```{r}
seurat_object_b = B_ALL_CAR.final.all.rerun[,cells.located]
```

```{r}
p <- SCpubr::do_DimPlot(sample = seurat_object_b,
                        plot.axes = TRUE,
                        group.by = "predicted.celltype",
                        colors.use = colors_use,
                        pt.size = 0.5)

p <- p + theme(legend.text = element_text(size = 6))
p <- p + ggtitle("UMAP of B-ALL Clusters Predicted Cell Types - 72h Samples")
p
filename <- "UMAP_B-ALL_Cluster_after_filtering_with_celltype.pdf"
path <- paste0(Task3_UMAP_after_filter)
ggsave(filename = file.path(path, filename), plot = p, width = 15, height = 12)
```

```{r}
plot <- DimPlot(object = B_ALL_CAR.final.all.rerun)
cells.located = CellSelector(plot = plot)
```

```{r}
seurat_object_b_cluster1 = B_ALL_CAR.final.all.rerun[,cells.located]
```

```{r}
p <- SCpubr::do_DimPlot(sample = seurat_object_b_cluster1,
                        plot.axes = TRUE,
                        group.by = "predicted.celltype",
                        colors.use = colors_use,
                        pt.size = 0.5)

p <- p + theme(legend.text = element_text(size = 6))
p <- p + ggtitle("UMAP of B-ALL Clusters1 Predicted Cell Types - 72h Samples")
p
filename <- "UMAP_B-ALL_Cluster1_after_filtering_with_celltype.pdf"
path <- paste0(Task3_UMAP_after_filter)
ggsave(filename = file.path(path, filename), plot = p, width = 10, height = 8)
```

```{r}
plot <- DimPlot(object = B_ALL_CAR.final.all.rerun)
cells.located = CellSelector(plot = plot)
```

```{r}
seurat_object_b_cluster2 = B_ALL_CAR.final.all.rerun[,cells.located]
```

```{r}
p <- SCpubr::do_DimPlot(sample = seurat_object_b_cluster2,
                        plot.axes = TRUE,
                        group.by = "predicted.celltype",
                        colors.use = colors_use,
                        pt.size = 0.5)

p <- p + theme(legend.text = element_text(size = 6))
p <- p + ggtitle("UMAP of B-ALL Clusters2 Predicted Cell Types - 72h Samples")
p
filename <- "UMAP_B-ALL_Cluster2_after_filtering_with_celltype.pdf"
path <- paste0(Task3_UMAP_after_filter)
ggsave(filename = file.path(path, filename), plot = p, width = 10, height = 8)
```

### Task 3.4.1 Check Cluster 1 and 2 Samples

```{r}
set.seed(123)
p <- DimPlot(seurat_object_b, reduction = "umap", group.by =  "predicted.celltype", label = TRUE, repel = TRUE, label.size = 3)
p
# filename <- "check_B-ALL_celltype_72h.pdf"
# path <- paste0(Task3_UMAP_after_filter)
# ggsave(filename = file.path(path, filename), plot = p, width = 10, height = 8)
```

```{r}
set.seed(123)
p <- DimPlot(seurat_object_b, reduction = "umap", group.by =  "new_labels", label = TRUE, repel = TRUE, label.size = 3)
p
# filename <- "check_B-ALL_newlabels_72h.pdf"
# path <- paste0(Task3_UMAP_after_filter)
# ggsave(filename = file.path(path, filename), plot = p, width = 10, height = 8)
```

```{r}
table(seurat_object_b_cluster1@meta.data$predicted.celltype)
table(seurat_object_b_cluster1@meta.data$new_labels)
```

```{r}
table(seurat_object_b_cluster2@meta.data$predicted.celltype)
table(seurat_object_b_cluster2@meta.data$new_labels)
```

```{r}
plot <- DimPlot(object = B_ALL_CAR.final.all.rerun)
cells.located = CellSelector(plot = plot)
```

```{r}
tail = B_ALL_CAR.final.all.rerun[,cells.located]
```

```{r}
table(tail@meta.data$predicted.celltype)
table(tail@meta.data$new_labels)
```

```{r}
set.seed(123)
p <- DimPlot(tail, reduction = "umap", group.by =  "predicted.celltype", label = TRUE, repel = TRUE, label.size = 3) 
p
```

```{r}
p <- DimPlot(tail, reduction = "umap", group.by =  "new_labels", label = TRUE, repel = TRUE, label.size = 3) 
p
```

## Task 3.5 Individual UMAPs

```{r}
Task3.5_Individual_Sample_UMAP <- paste0(Task3_UMAP_after_filter, "/Task3.5_Individual_Sample_UMAP")

if(!exists(Task3.5_Individual_Sample_UMAP)){
  dir.create(Task3.5_Individual_Sample_UMAP)
}
```

```{r}
table(B_ALL_CAR.final.all.rerun@meta.data$new_labels)
```

```{r}
rgb_values <- list(
  c(187, 70, 89),
  c(166, 106, 27),
  c(121, 125, 29),
  c(59, 139, 66),
  c(60, 145, 131),
  c(55, 141, 183),
  c(90, 82, 200),
  c(177, 71, 169)
)

# Convert RGB to hex
hex_colors <- sapply(rgb_values, function(rgb) {
  rgb(rgb[1], rgb[2], rgb[3], maxColorValue = 255)
})

hex_colors
```

```{r}
colors <- c("#BB4659", "#3B8B42", "#A66A1B",  "#378DB7", "#797D1D",  "#5A52C8", "#3C9183", "#B147A9")

new_labels_type <- c("KO_KO_CAR_72", "KO_KO_Mock_72", "KO_WT_CAR_72", "KO_WT_Mock_72", "WT_KO_CAR_72", "WT_KO_Mock_72", "WT_WT_CAR_72", "WT_WT_Mock_72")

label_colors <- setNames(colors, new_labels_type)

print(label_colors)
```

```{r}
 # KO_KO_CAR_72 KO_KO_Mock_72  KO_WT_CAR_72 KO_WT_Mock_72  WT_KO_CAR_72 WT_KO_Mock_72  WT_WT_CAR_72 WT_WT_Mock_72 
 #    "#BB4659"     "#3B8B42"     "#A66A1B"     "#378DB7"     "#797D1D"     "#5A52C8"     "#3C9183"     "#B147A9" 
```

```{r}
unique_labels <- unique(B_ALL_CAR.final.all.rerun@meta.data$new_labels)

# Create a list to hold all the plots
plot_list <- list()

for (label in unique_labels) {
  # Subset cells corresponding to the current label
  cells.use <- WhichCells(object = B_ALL_CAR.final.all.rerun, 
                          expression = new_labels == label)
  
  color_for_label <- label_colors[label][[1]]
  
  p <- SCpubr::do_DimPlot(sample = B_ALL_CAR.final.all.rerun, 
                          plot.axes = TRUE,
                          cells.highlight = cells.use, 
                          colors.use = color_for_label,
                          pt.size = 0.5,
                          na.value = "grey90") + 
       ggtitle(label)
  
  filename <- paste0("UMAP_", label, ".pdf")
  path <- paste0(Task3.5_Individual_Sample_UMAP)
  ggsave(filename = file.path(path, filename), plot = p, width = 20, height = 15)

  plot_list[[label]] <- p
}

# Combine all plots into one grid (2 rows, 4 columns)
combined_plot <- wrap_plots(plot_list, ncol = 4)

filename <- "Combined_UMAP_Plots_for_each_sample.pdf"
path <- paste0(Task3.5_Individual_Sample_UMAP)
ggsave(filename = file.path(path, filename), plot = combined_plot, width = 30, height = 20)
```

# SAVE POINT

```{r}
# saveRDS(seurat_object_t, file = paste0(save_point, "/T_cluster_final_rerun_72h.rds"))
# saveRDS(seurat_object_b, file = paste0(save_point, "/B-ALL_clusters_final_rerun_72h.rds"))
```

```{r}
seurat_object_t <- readRDS(paste0(save_point, "/T_cluster_final_rerun_72h.rds"))
seurat_object_b <- readRDS(paste0(save_point, "/B-ALL_clusters_final_rerun_72h.rds"))
```

# 4. Analysis for T Cells 

```{r}
Task4_T_Cell_Plots <- paste0(folder.name, "/Task4_T-Cell_Plots_72h")

if(!exists(Task4_T_Cell_Plots)){
  dir.create(Task4_T_Cell_Plots)
}
```

## Task 4.1 Bar Plot -- proportion of cell types

```{r}
seurat_object_t@meta.data
```

```{r}
table(seurat_object_t@meta.data$new_labels)
```

```{r}
# Define a colorblind-friendly palette
colors <- colour("muted") 

# Define cell types and assign colors
celltypes <- c("CD4 Memory", "CD8 Memory_2", "GMP", "Prog_B 1", "Prog_B 2", "Prog_RBC", "Treg", "CD4 Naive", "Prog_DC")

colors_use <- setNames(colors(length(celltypes)), celltypes)

# # Print colors for verification
# print(colors_use)

metadata_t <- seurat_object_t@meta.data

# Define the custom order for the samples
sample_order <- c(
  "WT_WT_Mock_72", "WT_KO_Mock_72", "KO_WT_Mock_72", "KO_KO_Mock_72",
  "WT_WT_CAR_72", "WT_KO_CAR_72", "KO_WT_CAR_72", "KO_KO_CAR_72"
)

# Calculate proportions of each cell type within each group
data_to_plot <- metadata_t %>%
  group_by(new_labels, predicted.celltype) %>%
  summarise(Count = n(), .groups = 'drop') %>%
  mutate(Total = sum(Count), Proportion = Count / Total) %>% 
  # Set the factor levels to control plot order
  mutate(new_labels = factor(new_labels, levels = sample_order))

p <- ggplot(data_to_plot, aes(x = new_labels, y = Proportion, fill = predicted.celltype)) +
  geom_bar(stat = "identity", position = "fill") +
  scale_fill_manual(values = colors_use) +  # Apply custom colors
  theme_minimal() +
  labs(x = "Samples", y = "Proportion", fill = "Cell Type", title = "Proportion of Cell Types within the T Cells Cluster") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
p

filename <- "Proportion_of_Cell_Types_within_the_T-Cells_Cluster.pdf"
path <- paste0(Task4_T_Cell_Plots)
ggsave(filename = file.path(path, filename), plot = p, width = 10, height = 8)
```

## Task 4.2 Bar Plots - Expression of Genes

```{r}
# Extract the expression data for the genes of interest
genes_of_interest <- c("GZMB", "PDCD1", "CD4", "CD8B", "IL7R")
expression_data <- FetchData(seurat_object_t, vars = genes_of_interest)

# Combine expression data with metadata
expression_data <- cbind(expression_data, seurat_object_t@meta.data$new_labels) %>% 
    rename(new_labels = `seurat_object_t@meta.data$new_labels`)

# Calculate the average expression for each gene within each group
average_expression <- expression_data %>%
  group_by(new_labels) %>%
  summarise(across(all_of(genes_of_interest), ~ mean(., na.rm = TRUE)))

# Reshape the data for plotting
average_expression_long <- pivot_longer(average_expression, cols = -new_labels, names_to = "Gene", values_to = "Expression")
```

```{r}
# Define colors and corresponding sample types
colors <- c("#BB4659", "#A66A1B", "#797D1D", "#3B8B42", 
            "#3C9183", "#378DB7", "#5A52C8", "#B147A9")

new_labels_type <- c("KO_KO_CAR_72", "KO_KO_Mock_72", 
                     "KO_WT_CAR_72", "KO_WT_Mock_72", 
                     "WT_KO_CAR_72", "WT_KO_Mock_72", 
                     "WT_WT_CAR_72", "WT_WT_Mock_72")

# Create named vector for label colors
label_colors <- setNames(colors, new_labels_type)
# print(label_colors)

plots <- list()

# Iterate over each gene to create separate plots
for (gene in genes_of_interest) {
  # Filter the long format data for the current gene
  gene_data <- average_expression_long %>% 
    filter(Gene == gene) %>% 
    mutate(new_labels = factor(new_labels, levels = sample_order))
  
  p <- ggplot(gene_data, aes(x = new_labels, y = Expression, fill = new_labels)) +
    geom_bar(stat = "identity", position = position_dodge()) +
    geom_text(aes(label = round(Expression, 3)), vjust = -0.5, position = position_dodge(width = 0.9), color = "black", size = 3) + 
    scale_fill_manual(values = label_colors) + # Set custom colors
    theme_minimal() +
    labs(title = paste("Expression of", gene),
         x = "Samples",
         y = "Average Expression") +
    theme(axis.text.x = element_text(angle = 45, hjust = 1), legend.position = "none")  # Hide legend
  
  # Store the plot in the list
  plots[[gene]] <- p
}

for (gene in names(plots)) {
  pdf_path <- paste0(Task4_T_Cell_Plots, "/Expression_of_", gene, ".pdf")
  pdf(pdf_path, width = 10, height = 8) 
  print(plots[[gene]]) 
  dev.off()
  print(plots[[gene]])
}
```

# 5. Analysis for B-ALL Cells 

```{r}
Task5_B_ALL_Cell_Plots <- paste0(folder.name, "/Task5_B-ALL_Cluster_Plots_72h")

if(!exists(Task5_B_ALL_Cell_Plots)){
  dir.create(Task5_B_ALL_Cell_Plots)
}
```

## Task 5.1 Cluster 1 vs. Cluster 2

```{r}
Task5.1_Cluster1_vs_Cluster2 <- paste0(Task5_B_ALL_Cell_Plots, "/Task5.1_Cluster1_vs_Cluster2")
  
if(!exists(Task5.1_Cluster1_vs_Cluster2)){
  dir.create(Task5.1_Cluster1_vs_Cluster2)
}
```

### Task 5.1.1 DE gene analysis

```{r}
Task5.1.1_DE_genes <- paste0(Task5.1_Cluster1_vs_Cluster2, "/Task5.1.1_DE_genes")
  
if(!exists(Task5.1.1_DE_genes)){
  dir.create(Task5.1.1_DE_genes)
}
```

```{r}
# head(Idents(seurat_object_b))

plot <- DimPlot(object = seurat_object_b)
cells.located_cluster_1 = CellSelector(plot = plot)
```

```{r}
# Assign a new identity to selected cells
Idents(seurat_object_b, cells = cells.located_cluster_1) <- "Cluster_1"
```

```{r}
plot <- DimPlot(object = seurat_object_b)
cells.located_cluster_2 = CellSelector(plot = plot)
```

```{r}
# Assign a new identity to selected cells
Idents(seurat_object_b, cells = cells.located_cluster_2) <- "Cluster_2"
```

```{r}
table(Idents(seurat_object_b))
```

```{r}
names(seurat_object_b)
```

```{r}
seurat_object_b <- subset(seurat_object_b, idents = c("Cluster_1", "Cluster_2"))
```

```{r}
table(Idents(seurat_object_b))
```

```{r}
seurat_object_b <- JoinLayers(seurat_object_b)
seurat_object_b
```

```{r}
markers <- FindMarkers(seurat_object_b, ident.1 = "Cluster_1", ident.2 = "Cluster_2", logfc.threshold = 0.25, min.pct = 0.1)
```

```{r}
head(markers)
```

```{r}
# Summarize top markers
top_markers <- markers %>%
  arrange(p_val_adj) %>%
  head(n = 20)

top_markers
```

# SAVE POINT

```{r}
# write.csv(markers, paste0(Task5.1.1_DE_genes, "/marker_results_72h.csv"), row.names = TRUE)
# write.csv(top_markers, paste0(Task5.1.1_DE_genes, "/top_marker_results_72h.csv"), row.names = TRUE)
# 
# markers <- read.csv(paste0(Task5.1.1_DE_genes, "/marker_results_72h.csv"), row.names = 1)
```

### Task 5.1.2 GSEA Hallmarks analysis 

```{r}
Task5.1.2_GSEA_Hallmark_results <- paste0(Task5.1_Cluster1_vs_Cluster2, "/Task5.1.2_GSEA_Hallmark_results")
if(!dir.exists(Task5.1.2_GSEA_Hallmark_results)) {
  dir.create(Task5.1.2_GSEA_Hallmark_results, recursive = TRUE)
}
```

```{r}
msigdbr.Hallmark.df = msigdbr(species = "Homo sapiens", category = "H")
msigdbr.Hallmark.df
```

```{r}
fgsea_hallmark_sets = msigdbr.Hallmark.df %>% 
  # mutate(gs_name = str_remove(gs_name, "HALLMARK_")) %>% 
  split(x = .$gene_symbol, f = .$gs_name)

length(names(fgsea_hallmark_sets))
```

```{r}
markers_to_rank <- markers
markers_to_rank$gene_symbol <- rownames(markers_to_rank)
markers_to_rank
```

```{r}
# Rank genes
# Genes with the highest positive log fold changes are ranked at the top, and genes with the highest negative log fold changes are ranked at the bottom.

markers_to_rank |>
  dplyr::select(gene_symbol, avg_log2FC) |>
  arrange(desc(avg_log2FC)) |>
  deframe() -> ranks
```

```{r}
# The enrichment scores will be calculated based on the ranks to assess whether gene sets are enriched toward the top or bottom of the ranked list
fgseaRes = fgsea(fgsea_hallmark_sets, stats = ranks)

# In practical terms, if log2err is set to NA for certain pathways, it implies that the confidence in the P-values for those pathways is lower, and they might have been overestimated. This typically happens when there aren't enough permutations or when pathway sizes are too small to yield a robust estimation of P-values.
```

```{r}
# Positive NES: Indicates that the gene set is enriched in Cluster 1 relative to Cluster 2.
# Negative NES: Indicates that the gene set is enriched in Cluster 2 relative to Cluster 1.
# Significant p-values/FDR: Highlight the most robustly enriched pathways.

fgseaResTidy = fgseaRes %>%
    mutate(abbrev_pathway = abbreviate(pathway)) |> 
    relocate(abbrev_pathway, .after = pathway) |> 
    as_tibble() %>%
    arrange(desc(NES))

  write_csv(fgseaResTidy, file = paste0(Task5.1.2_GSEA_Hallmark_results, "/GSEA_HALLMARK_B-ALL_Cluster1_versus_Cluster2.csv"))
  
  # only plot the top 40 pathways
  fgseaResTidy %>%
    mutate(NES2 = ifelse(NES>0, "Enriched in Cluster1", "Enriched in Cluster2")) %>%
    # mutate(pathway = abbreviate(pathway)) |> 
    # dplyr::filter(padj < 0.05) %>%
    dplyr::filter(pval < 0.05) %>%
    arrange(desc(NES)) %>%
    head(n = 40) -> GSEA.plot.data
  
  # Output plot data to CSV
  GSEA.plot.data %>% 
    mutate(Lead_size = as.integer(map(leadingEdge, length))) %>% 
    mutate(Lead_Genes = as.character(map(leadingEdge, paste0, collapse = ","))) %>%
    dplyr::select(-c(leadingEdge, NES2, size)) %>% 
    write_csv(file = paste0(Task5.1.2_GSEA_Hallmark_results, "/GSEA_HALLMARK_Plot_data_B-ALL_Cluster1_versus_Cluster2.csv"))

  # Column Plot
  cols = c("Enriched in Cluster1" = "green", "Enriched in Cluster2" = "red")
  
  GSEA.plot.data %>% 
    ggplot(aes(fct_reorder(pathway, NES), NES)) +
      geom_col(aes(fill= NES2)) +
      scale_fill_manual("NES", values = cols) +
      coord_flip() + 
      theme(axis.text.y = element_text(size = 6)) +
      labs(x="Pathway", y="Normalized Enrichment Score",
           title=paste0("B-ALL_Cluster1_versus_Cluster2_72h")) 
  
    ggsave(filename = paste0(Task5.1.2_GSEA_Hallmark_results, "/GSEA_HALLMARK_B-ALL_Cluster1_versus_Cluster2.pdf"))
```

```{r}
# Top 10 Pathways for positive and negative pathways

fgseaResTidy %>%
  mutate(NES2 = ifelse(NES > 0, "Enriched in Cluster1", "Enriched in Cluster2")) %>%
  # Splitting the data into positive and negative NES pathways and selecting top 10 by smallest p-values
  group_by(NES2) %>%
  # filter(pval < 0.05) %>%
  arrange(pval) %>%
  slice_head(n = 10) %>%
  ungroup() %>%
  # Combining top positive and negative pathways
  bind_rows() %>%
  arrange(desc(NES)) -> GSEA.plot.data.pos_and_neg

# Output plot data to CSV
GSEA.plot.data.pos_and_neg %>% 
    mutate(Lead_size = as.integer(map(leadingEdge, length))) %>% 
    mutate(Lead_Genes = as.character(map(leadingEdge, paste0, collapse = ","))) %>%
    dplyr::select(-c(leadingEdge, NES2, size)) %>% 
    write_csv(file = paste0(Task5.1.2_GSEA_Hallmark_results, "/GSEA_HALLMARK_Plot_data_B-ALL_Cluster1_versus_Cluster2_pos_and_neg_top.csv"))

# Column Plot
cols = c("Enriched in Cluster1" = "green", "Enriched in Cluster2" = "red")
  
GSEA.plot.data.pos_and_neg %>% 
    ggplot(aes(fct_reorder(pathway, NES), NES)) +
      geom_col(aes(fill= NES2)) +
      scale_fill_manual("NES", values = cols) +
      # scale_fill_discrete(labels=c("Positive", "Negative")) +
      coord_flip() + 
      theme(axis.text.y = element_text(size = 6)) +
      labs(x="Pathway", y="Normalized Enrichment Score",
           title=paste0("B-ALL_Cluster1_versus_Cluster2_top10_72h")) 
  
ggsave(filename = paste0(Task5.1.2_GSEA_Hallmark_results, "/GSEA_HALLMARK_B-ALL_Cluster1_versus_Cluster2_pos_and_neg_top.pdf"))
```

### Task 5.1.3 Two gene expression csv files for all samples

```{r}
Task5.1.3_Gene_expression_for_all_samples <- paste0(Task5.1_Cluster1_vs_Cluster2, "/Task5.1.3_Gene_expression_for_all_samples")
  
if(!exists(Task5.1.3_Gene_expression_for_all_samples)){
  dir.create(Task5.1.3_Gene_expression_for_all_samples)
}
```

```{r}
# seurat_object_b <- readRDS(paste0(save_point, "/B-ALL_clusters_final_rerun_Cluster1and2.rds"))

sample_order <- c(
  "WT_WT_Mock_72", "WT_KO_Mock_72", "KO_WT_Mock_72", "KO_KO_Mock_72",
  "WT_WT_CAR_72", "WT_KO_CAR_72", "KO_WT_CAR_72", "KO_KO_CAR_72"
)

# Replace underscores with hyphens
sample_order <- gsub("_", "-", sample_order)

# Function to calculate average expression per sample and cluster
calculate_average_expression <- function(seurat_obj, cluster) {
  # Subset by cluster
  subset_cluster <- subset(seurat_obj, idents = cluster)

  # Calculate average expression
  avg_expression <- AverageExpression(subset_cluster, group.by = "new_labels", return.seurat = FALSE)$RNA
  
  avg_expression <- avg_expression[, sample_order]
}

# Calculate average expression for Cluster 1 and Cluster 2
### already normalized by log1p which is log(UMI + 1), but log(1) = 0, so there still many 0s.
avg_exp_cluster1 <- calculate_average_expression(seurat_object_b, "Cluster_1")
avg_exp_cluster2 <- calculate_average_expression(seurat_object_b, "Cluster_2")

avg_exp_cluster1 <- as.matrix(avg_exp_cluster1)
avg_exp_cluster2 <- as.matrix(avg_exp_cluster2)

# Save to CSV
write.csv(avg_exp_cluster1, paste0(Task5.1.3_Gene_expression_for_all_samples, "/avg_exp_cluster1.csv"), row.names = TRUE)
write.csv(avg_exp_cluster2, paste0(Task5.1.3_Gene_expression_for_all_samples, "/avg_exp_cluster2.csv"), row.names = TRUE)
```

### Task 5.1.4 Violin Plots for some genes

```{r}
Task5.1.4_Violin_plot_for_some_genes <- paste0(Task5.1_Cluster1_vs_Cluster2, "/Task5.1.4_Violin_plot_for_some_genes")
  
if(!exists(Task5.1.4_Violin_plot_for_some_genes)){
  dir.create(Task5.1.4_Violin_plot_for_some_genes)
}
```

```{r}
table(Idents(seurat_object_b))
```

```{r}
# List of genes to plot
genes_to_plot <- c("RELA", "TP53", "MDM2", "BAX", "CD19", "GADD45A", "BCL2L11", "SLC27A2")

sample_order <- c(
  "WT_WT_Mock_72", "WT_KO_Mock_72", "KO_WT_Mock_72", "KO_KO_Mock_72",
  "WT_WT_CAR_72", "WT_KO_CAR_72", "KO_WT_CAR_72", "KO_KO_CAR_72"
)
```

```{r}
base_dir <- Task5.1.4_Violin_plot_for_some_genes

for (cluster in c("Cluster_1", "Cluster_2")) {
  plot_list <- list()
  
  cluster_data <- subset(seurat_object_b, idents = cluster)
  cluster_dir <- paste0(base_dir, "/", cluster)
  if (!dir.exists(cluster_dir)) {
    dir.create(cluster_dir, recursive = TRUE)
  }
  
  for (gene in genes_to_plot) {
    
    gene_data <- FetchData(cluster_data, vars = gene)
    gene_data$new_labels <- cluster_data@meta.data$new_labels
    
    filtered_data <- gene_data[gene_data[[gene]] > 0, ]

    filtered_data$new_labels <- factor(
      filtered_data$new_labels, 
      levels = sample_order
    )

    p <- ggplot(filtered_data, aes(x = new_labels, y = !!sym(gene), fill = as.factor((as.integer(new_labels) - 1) %/% 2))) +
        geom_violin(trim = TRUE) +
        stat_summary(fun = mean, geom = "errorbar", width = 0.2, 
                 color = "black", size = 0.5, linetype = "solid",
                 aes(ymin = ..y.., ymax = ..y..)) + 
        scale_fill_brewer(palette = "Paired") +
        theme_minimal() +
        theme(axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1), legend.position = "none") +
        labs(title = paste("Expression of", gene, "in", cluster),
             x = "Sample Group",
             y = "Expression Level")
    
    print(p)
    
    pdf_filename <- paste0(cluster_dir, "/Expression_", gene, "_", cluster, "_violin_plot.pdf")
    ggsave(filename = pdf_filename, plot = p, width = 14, height = 8)
    plot_list[[gene]] <- p
  }
  
  combined_plot <- wrap_plots(plot_list, ncol = 3)
  ggsave(filename = paste0(cluster_dir, "/combined_Violin_Plot.pdf"), 
       plot = combined_plot, width = 24, height = 15)
}
```

## Task 5.2 Bar plot - proportion of each cluster or cell typoe in each sample

```{r}
bar_plot_data <- as.data.frame(seurat_object_b@meta.data)
bar_plot_data$cluster <- Idents(seurat_object_b)  # Add cluster identities as a column

# Calculate proportions of each cluster within each sample
proportion_data <- bar_plot_data %>%
  group_by(new_labels) %>%
  dplyr::count(cluster) %>%
  mutate(proportion = n / sum(n)) %>%
  ungroup() %>% 
  # Set the factor levels to control plot order
  mutate(new_labels = factor(new_labels, levels = sample_order))

proportion_data
```

```{r}
# Plot for Cluster proportions
cluster_proportions_plot <- ggplot(proportion_data, aes(x = new_labels, y = proportion, fill = cluster)) +
  geom_bar(stat = "identity", position = "stack") +
  geom_text(aes(label = scales::percent(proportion, accuracy = 0.01)), position = position_fill(vjust = 0.5), size = 2, color = "white") +
  labs(x = "Samples", y = "Proportion of Clusters", title = "Proportion of B-ALL Clusters in Each Sample") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

print(cluster_proportions_plot)

filename <- "Task5.2_Proportion_of_B-ALL_Clusters_in_Each_Sample.pdf"
path <- paste0(Task5_B_ALL_Cell_Plots)
ggsave(filename = file.path(path, filename), plot = cluster_proportions_plot, width = 10, height = 8)
```


```{r}
metadata_b <- seurat_object_b@meta.data

# Define the custom order for the samples
sample_order <- c(
  "WT_WT_Mock_72", "WT_KO_Mock_72", "KO_WT_Mock_72", "KO_KO_Mock_72",
  "WT_WT_CAR_72", "WT_KO_CAR_72", "KO_WT_CAR_72", "KO_KO_CAR_72"
)

# Calculate proportions of each cell type within each group
data_to_plot <- metadata_b %>%
  group_by(new_labels, predicted.celltype) %>%
  summarise(Count = n(), .groups = 'drop') %>%
  mutate(Total = sum(Count), Proportion = Count / Total) %>% 
  # Set the factor levels to control plot order
  mutate(new_labels = factor(new_labels, levels = sample_order))

p <- ggplot(data_to_plot, aes(x = new_labels, y = Proportion, fill = predicted.celltype)) +
  geom_bar(stat = "identity", position = "fill") +
  theme_minimal() +
  scale_fill_manual(values = colors_use) +  # Apply custom colors
  labs(x = "Samples", y = "Proportion", fill = "Cell Type", title = "Proportion of Cell Types within the B-ALL Cluster") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
p

filename <- "Task5.2_Proportion_of_Cell_Types_within_the_B-ALL_Cluster_72h.pdf"
path <- paste0(Task5_B_ALL_Cell_Plots)
ggsave(filename = file.path(path, filename), plot = p, width = 10, height = 8)
```

## Task 5.3 UMAP Comparison

```{r}
Task5.3_UMAP_Comparison <- paste0(Task5_B_ALL_Cell_Plots, "/Task5.3_UMAP_Comparison")
  
if(!exists(Task5.3_UMAP_Comparison)){
  dir.create(Task5.3_UMAP_Comparison)
}
```

### Task 5.3.2 Mock vs. CAR

```{r}
Task5.3.2_Mock_vs_CAR <- paste0(Task5.3_UMAP_Comparison, "/Task5.3.2_Mock_vs_CAR")
  
if(!exists(Task5.3.2_Mock_vs_CAR)){
  dir.create(Task5.3.2_Mock_vs_CAR)
}
```

```{r}
# Define the main conditions and time points
conditions <- c("KO_KO", "KO_WT", "WT_KO", "WT_WT")
time_points <- c("72")

# Initialize a list to store plots
plot_list <- list()

# Loop through each condition and time point
for (condition in conditions) {
  for (time in time_points) {
    # Define the groups for CAR and Mock within each condition at a specific time
    group_Mock <- paste(condition, "Mock", time, sep = "_")
    group_CAR <- paste(condition, "CAR", time, sep = "_")

    # Subset the Seurat object for CAR and Mock groups at the current time
    subset_seurat <- subset(seurat_object_b, subset = new_labels %in% c(group_Mock, group_CAR))
    
    # Plot UMAP comparing CAR vs Mock at this time point
    plot_title <- paste(condition, "Mock vs CAR at", time, "hours")
    p <- UMAPPlot(subset_seurat, label = FALSE, group.by = "new_labels", pt.size = 0.2) +
      ggtitle(plot_title) +
      theme_minimal()

    # Store the plot in the list with a unique key
    key <- paste(condition, time, sep = "_")
    plot_list[[key]] <- p
    
    # Optionally save the plot to a PDF
    ggsave(paste0(Task5.3.2_Mock_vs_CAR, "/", condition, "_", time, "_UMAP.pdf"), plot = p, width = 10, height = 8)
  }
}

# Combine all plots into one PDF file
combined_plot <- wrap_plots(plot_list, ncol = 2) 
ggsave(paste0(Task5.3.2_Mock_vs_CAR, "/All_UMAP_Mock_vs_CAR.pdf"), plot = combined_plot, width = 20, height = 15)
```

## Task 5.4 Mock vs. CAR in each sample

```{r}
Task5.4_Mock_vs_CAR <- paste0(Task5_B_ALL_Cell_Plots, "/Task5.4_Mock_vs_CAR")
  
if(!exists(Task5.4_Mock_vs_CAR)){
  dir.create(Task5.4_Mock_vs_CAR)
}
```

### Task 5.4.1 DE gene analysis

```{r}
Task5.4.1_DE_genes <- paste0(Task5.4_Mock_vs_CAR, "/Task5.4.1_DE_genes")
  
if(!exists(Task5.4.1_DE_genes)){
  dir.create(Task5.4.1_DE_genes)
}
```

```{r}
seurat_object_b@meta.data
```

```{r}
# For loop for all samples:

# Initialize containers for results
de_results_list <- list()
de_results_tibble <- tibble()

conditions <- c("WT_WT", "WT_KO", "KO_WT", "KO_KO")
time_points <- c("72")

for (condition in conditions) {
  for (time in time_points) {
    # Define new labels for CAR and Mock
    car_label <- paste(condition, "CAR", time, sep = "_")
    mock_label <- paste(condition, "Mock", time, sep = "_")
      
    # Subset Seurat object for the current combination
    subset_seurat <- subset(seurat_object_b, subset = new_labels %in% c(car_label, mock_label))
      
    # Set identities to be specifically the conditions for DE analysis
    Idents(subset_seurat) <- subset_seurat$new_labels
      
    # Check if there are enough cells to perform DE analysis
    if (length(table(Idents(subset_seurat))) < 2) {
      cat("Not enough data to perform DE analysis for", car_label, "vs", mock_label, "\n")
      next
    }
      
    # Perform DE analysis
    de_results <- FindMarkers(subset_seurat, ident.1 = mock_label, ident.2 = car_label, min.pct = 0.1, logfc.threshold = 0.25)
    # Save results to list
    de_results_list[[paste(condition, time, "Mock_vs_CAR", sep = "_")]] <- de_results

    # Directory for saving the results
    result_dir <- paste0(Task5.4.1_DE_genes, "/", condition)
    if (!dir.exists(result_dir)) {
      dir.create(result_dir, recursive = TRUE)
    }
      
    # Save DE results to CSV
    write.csv(de_results, paste0(result_dir, "/", condition, "_", time, "_Mock_vs_CAR.csv"))
  }
}
```

```{r}
de_results_list
```

```{r}
# Convert the list of DE results into a tibble
de_results_tibble <- tibble(
  Comparison = names(de_results_list),
  Results = de_results_list
)
```

# SAVE POINT

```{r}
# saveRDS(de_results_tibble, file = paste0(save_point, "/de_results_tibble_72h.rds"))

# de_results_tibble <- readRDS(paste0(save_point, "/de_results_tibble_72h.rds"))
```

### Task 5.4.2 GSEA Hallmarks

```{r}
Task5.4.2_GSEA_Hallmark_results <- paste0(Task5.4_Mock_vs_CAR, "/Task5.4.2_GSEA_Hallmark_results")
  
if(!exists(Task5.4.2_GSEA_Hallmark_results)){
  dir.create(Task5.4.2_GSEA_Hallmark_results)
}
```

```{r}
GSEA_sample_dir_significant <- paste0(Task5.4.2_GSEA_Hallmark_results, "/most_significant_pathways")

if(!dir.exists(paste0(GSEA_sample_dir_significant, "/res_data"))) {
  dir.create(paste0(GSEA_sample_dir_significant, "/res_data"), recursive = TRUE)
}

if(!dir.exists(paste0(GSEA_sample_dir_significant, "/plot_data"))) {
  dir.create(paste0(GSEA_sample_dir_significant, "/plot_data"), recursive = TRUE)
}

if(!dir.exists(paste0(GSEA_sample_dir_significant, "/Plots"))) {
  dir.create(paste0(GSEA_sample_dir_significant, "/Plots"), recursive = TRUE)
}
```

```{r}
# Prepare Hallmark gene sets for fgsea
prepareGeneSets <- function() {
  msigdbr.Hallmark.df <- msigdbr(species = "Homo sapiens", category = "H")
  fgsea_hallmark_sets <- msigdbr.Hallmark.df %>% 
    split(x = .$gene_symbol, f = .$gs_name)
  return(fgsea_hallmark_sets)
}

# Perform fgsea and handle results
run_fgsea_save_results <- function(de_results, comparison_name, output_dir) {
  # Generate ranks for fgsea
  markers_to_rank <- as.data.frame(de_results)
  markers_to_rank$gene_symbol <- rownames(markers_to_rank)
  
  ranks <- markers_to_rank %>%
    dplyr::select(gene_symbol, avg_log2FC) %>%
    arrange(desc(avg_log2FC)) %>%
    deframe()

  # Run fgsea
  fgseaRes <- fgsea(prepareGeneSets(), stats = ranks)
  
  # Process and save results
  fgseaResTidy <- fgseaRes %>%
    mutate(abbrev_pathway = abbreviate(pathway)) |> 
    relocate(abbrev_pathway, .after = pathway) |> 
    as_tibble() %>%
    arrange(desc(NES))
  
  write_csv(fgseaResTidy, file = paste0(output_dir, "/res_data/GSEA_HALLMARK_B-ALL_", comparison_name, ".csv"))
  
  # Output plots
  output_plotData(fgseaResTidy, comparison_name, output_dir)
}

# Output plots and summary tables
output_plotData <- function(fgseaResTidy, comparison_name, output_dir) {
  # only plot the top 40 pathways
  fgseaResTidy %>%
    mutate(NES2 = ifelse(NES > 0, "Enriched in Mock", "Enriched in CAR")) %>%
    filter(pval < 0.05) %>%
    arrange(desc(NES)) %>%
    head(n = 40) -> GSEA.plot.data

  GSEA.plot.data %>%
    mutate(Lead_size = as.integer(map(leadingEdge, length))) %>%
    mutate(Lead_Genes = as.character(map(leadingEdge, paste0, collapse = ","))) %>%
    dplyr::select(-c(leadingEdge, NES2, size)) %>% 
    write_csv(file = paste0(output_dir, "/plot_data/GSEA_HALLMARK_Plot_data_", comparison_name, ".csv"))

  # Column Plot
  cols = c("Enriched in Mock" = "green", "Enriched in CAR" = "red")
  
  p <- GSEA.plot.data %>%
      ggplot(aes(fct_reorder(pathway, NES), NES)) +
      geom_col(aes(fill = NES2)) +
      # scale_fill_manual("NES", values = cols) +
      scale_fill_manual("NES", values = cols, breaks = c("Enriched in Mock", "Enriched in CAR")) +
      coord_flip() + 
      theme(axis.text.y = element_text(size = 6)) +
      labs(x = "Pathway", y = "Normalized Enrichment Score", title = comparison_name)
  ggsave(filename = paste0(output_dir, "/Plots/GSEA_HALLMARK_B-ALL_", comparison_name, ".pdf"))
    
  return(p)
}

# Loop through each comparison
results <- de_results_tibble

# Store plot objects in a list
plot_list <- list()

for (i in seq_len(nrow(results))) {
  comparison_name <- results$Comparison[i]
  de_results_sample <- results$Results[[i]]
  output_dir <- GSEA_sample_dir_significant
  
  # run_fgsea_save_results(de_results_sample, comparison_name, output_dir)
  plot_list[[comparison_name]] <- run_fgsea_save_results(de_results_sample, comparison_name, output_dir)
}

# Assuming 2x2 grid for 4 plots
combined_plot <- wrap_plots(plot_list, ncol = 2)
ggsave(filename = paste0(GSEA_sample_dir_significant, "/combined_GSEA_plots.pdf"), 
       plot = combined_plot, width = 15, height = 8)
```

```{r}
GSEA_sample_dir_pos_neg <- paste0(Task5.4.2_GSEA_Hallmark_results, "/pos_and_neg_top_pathways")

if(!dir.exists(paste0(GSEA_sample_dir_pos_neg, "/res_data"))) {
  dir.create(paste0(GSEA_sample_dir_pos_neg, "/res_data"), recursive = TRUE)
}

if(!dir.exists(paste0(GSEA_sample_dir_pos_neg, "/plot_data"))) {
  dir.create(paste0(GSEA_sample_dir_pos_neg, "/plot_data"), recursive = TRUE)
}

if(!dir.exists(paste0(GSEA_sample_dir_pos_neg, "/Plots"))) {
  dir.create(paste0(GSEA_sample_dir_pos_neg, "/Plots"), recursive = TRUE)
}
```

```{r}
# Select the top pathways that are enriched in Mock and CAR, respectively:

# Prepare Hallmark gene sets for fgsea
prepareGeneSets <- function() {
  msigdbr.Hallmark.df <- msigdbr(species = "Homo sapiens", category = "H")
  fgsea_hallmark_sets <- msigdbr.Hallmark.df %>% 
    split(x = .$gene_symbol, f = .$gs_name)
  return(fgsea_hallmark_sets)
}

# Perform fgsea and handle results
run_fgsea_save_results <- function(de_results, comparison_name, output_dir) {
  # Generate ranks for fgsea
  markers_to_rank <- as.data.frame(de_results)
  markers_to_rank$gene_symbol <- rownames(markers_to_rank)
  
  ranks <- markers_to_rank %>%
    dplyr::select(gene_symbol, avg_log2FC) %>%
    arrange(desc(avg_log2FC)) %>%
    deframe()

  # Run fgsea
  fgseaRes <- fgsea(prepareGeneSets(), stats = ranks)
  
  # Process and save results
  fgseaResTidy <- fgseaRes %>%
    mutate(abbrev_pathway = abbreviate(pathway)) |> 
    relocate(abbrev_pathway, .after = pathway) |> 
    as_tibble() %>%
    arrange(desc(NES))
  
  write_csv(fgseaResTidy, file = paste0(output_dir, "/res_data/GSEA_HALLMARK_B-ALL_", comparison_name, ".csv"))
  
  # Output plots
  output_plotData(fgseaResTidy, comparison_name, output_dir)
}

# Output plots and summary tables
output_plotData <- function(fgseaResTidy, comparison_name, output_dir) {
  # only plot the top 40 pathways
  fgseaResTidy %>%
    mutate(NES2 = ifelse(NES > 0, "Enriched in Mock", "Enriched in CAR")) %>%
    group_by(NES2) %>%
    arrange(pval) %>%
    slice_head(n = 10) %>%
    ungroup() %>%
    bind_rows() %>%
    arrange(desc(NES)) -> GSEA.plot.data.pos_and_neg
  
  GSEA.plot.data.pos_and_neg %>%
    mutate(Lead_size = as.integer(map(leadingEdge, length))) %>%
    mutate(Lead_Genes = as.character(map(leadingEdge, paste0, collapse = ","))) %>%
    dplyr::select(-c(leadingEdge, NES2, size)) %>% 
    write_csv(file = paste0(output_dir, "/plot_data/GSEA_HALLMARK_Plot_data_", comparison_name, ".csv"))

  # Column Plot
  cols = c("Enriched in Mock" = "green", "Enriched in CAR" = "red")
  
  p <- GSEA.plot.data.pos_and_neg %>%
    ggplot(aes(fct_reorder(pathway, NES), NES)) +
    geom_col(aes(fill = NES2)) +
    # scale_fill_manual("NES", values = cols) +
    scale_fill_manual("NES", values = cols, breaks = c("Enriched in Mock", "Enriched in CAR")) +
    coord_flip() + 
    theme(axis.text.y = element_text(size = 6)) +
    labs(x = "Pathway", y = "Normalized Enrichment Score", title = comparison_name)
  ggsave(filename = paste0(output_dir, "/Plots/GSEA_HALLMARK_B-ALL_", comparison_name, ".pdf"))
  
  return(p)
}

# Loop through each comparison
results <- de_results_tibble

plot_list <- list()

for (i in seq_len(nrow(results))) {
  comparison_name <- results$Comparison[i]
  de_results_sample <- results$Results[[i]]
  output_dir <- GSEA_sample_dir_pos_neg
  
  plot_list[[comparison_name]] <- run_fgsea_save_results(de_results_sample, comparison_name, output_dir)
}

# Assuming 2x2 grid for 4 plots
combined_plot <- wrap_plots(plot_list, ncol = 2)
ggsave(filename = paste0(GSEA_sample_dir_pos_neg, "/combined_GSEA_plots.pdf"), 
       plot = combined_plot, width = 15, height = 8)
```

### Task 5.4.3 GSEA C2 CP KEGG_LEGACY

```{r}
Task5.4.3_GSEA_KEGG_MAPK_SIGNALING_PATHWAY <- paste0(Task5.4_Mock_vs_CAR, "/Task5.4.3_GSEA_KEGG_MAPK_SIGNALING_PATHWAY")
  
if(!exists(Task5.4.3_GSEA_KEGG_MAPK_SIGNALING_PATHWAY)){
  dir.create(Task5.4.3_GSEA_KEGG_MAPK_SIGNALING_PATHWAY)
}
```

```{r}
#### C2 CP:KEGG_LEGACY

msigdbr.C2.CP.KL.df = msigdbr(species = "Homo sapiens", category = "C2", subcategory = "CP:KEGG")
# msigdbr.C2.CP.KL.df
```

```{r}
msigdbr.C2.CP.KL.df_set = msigdbr.C2.CP.KL.df %>% 
  split(x = .$gene_symbol, f = .$gs_name)
```

```{r}
pathway <- "KEGG_MAPK_SIGNALING_PATHWAY"

plot_list <- list()

# Iterate over each comparison in the de_results_tibble
for(i in seq_along(de_results_tibble$Comparison)) {
  comparison_name <- de_results_tibble$Comparison[i]
  markers_to_rank <- de_results_tibble$Results[[i]]
  
  # Prepare the ranks
  markers_to_rank$gene_symbol <- rownames(markers_to_rank)
  ranks <- markers_to_rank %>%
    dplyr::select(gene_symbol, avg_log2FC) %>%
    arrange(desc(avg_log2FC)) %>%
    deframe()
  
  # Run fgsea
  fgseaRes <- fgsea(msigdbr.C2.CP.KL.df_set, stats = ranks)
  
  # Plot enrichment
  plot <- plotEnrichment(msigdbr.C2.CP.KL.df_set[[pathway]], ranks) +
    labs(title = paste(pathway, ":", comparison_name)) +
    annotate("text", x = -Inf, y = -Inf, hjust = 0, vjust = -0.3, label = "Enriched in Mock") +
    annotate("text", x = Inf, y = -Inf, hjust = 1, vjust = -0.3, label = "Enriched in CAR")
  
  ggsave(filename = paste0(Task5.4.3_GSEA_KEGG_MAPK_SIGNALING_PATHWAY, "/plotEnrichment_", comparison_name, ".pdf"), plot = plot, width = 8, height = 6, units = "in")
  
  plot_list[[comparison_name]] <- plot
}

# Assuming 2x2 grid for 4 plots
combined_plot <- wrap_plots(plot_list, ncol = 2)
ggsave(filename = paste0(Task5.4.3_GSEA_KEGG_MAPK_SIGNALING_PATHWAY, "/combined_Enrichment_plots.pdf"),
       plot = combined_plot, width = 15, height = 8)
```

# End

```{r}
tail@meta.data
```

```{r}
VlnPlot(B_ALL_CAR.final.all.rerun, features = c("mitoRatio"))
# nCount_RNA
# nFeature_RNA
```

```{r}
mitochondrial_genes <- grep("^MT-", rownames(tail), value = TRUE)
```

```{r}
DefaultAssay(tail) <- "RNA"
grep("^MT-", rownames(GetAssayData(tail, assay = "RNA")), value = TRUE)


tail$percent.mt <- PercentageFeatureSet(tail, pattern = "^MT-")
```

```{r}
pbmc[["percent.mt"]] <- PercentageFeatureSet(tail, pattern = "^MT-")
```

```{r}
# Step 1: Identify mitochondrial genes
mitochondrial_genes <- grep("^MT-", rownames(tail@assays$RNA@counts), value = TRUE)

# Step 2: Specify the cell IDs of interest
cell_ids_of_interest <- c("AAACCTGAGAAACCAT-1", "AAACCTGAGATAGCAT-1", "AAACCTGAGCGTGAAC-1")

# Step 3: Extract mitochondrial gene expression data
mt_gene_matrix <- GetAssayData(seurat_object, slot = "counts")[mitochondrial_genes, cell_ids_of_interest]
mt_gene_df <- as.data.frame(t(mt_gene_matrix))

# Step 4: Add Cell IDs as a column
mt_gene_df$Cell_ID <- rownames(mt_gene_df)
mt_gene_df <- mt_gene_df[, c("Cell_ID", setdiff(colnames(mt_gene_df), "Cell_ID"))]

# Step 5: Save the data frame (optional)
write.csv(mt_gene_df, "mitochondrial_gene_expression.csv", row.names = FALSE)

# Preview the resulting data frame
head(mt_gene_df)
```


