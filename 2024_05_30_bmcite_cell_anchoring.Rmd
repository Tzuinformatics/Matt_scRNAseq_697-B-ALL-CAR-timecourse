---
title: "2024_05_30_bmcite_cell_anchoring"
output: html_document
date: "2024_05_30"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Import Libraries

```{r}
script.date = "2024_05_30"

folder.name = "2024_05_30_bmcite_cell_anchoring"

set.seed(123)

if(!exists(folder.name)){
  dir.create(folder.name, recursive = TRUE)
}

save_point = paste0(folder.name, "/SAVE_POINT")

library(tidyverse)
library(symphony)
library(ggpubr)
library(patchwork)
library(BoneMarrowMap)
library(SeuratWrappers)
library(SingleCellExperiment)
library(ComplexHeatmap)
library(circlize)
library(Seurat)
library(SeuratData)
library(SeuratObject)
library(ggplot2)
library(RColorBrewer)
library(dittoSeq)
library(plotly)
library(htmlwidgets)
library(dplyr)
library(clusterProfiler)
library(org.Hs.eg.db)
library(msigdbr)
library(fgsea)
library(Rcpp)
library(harmony)
library(rlang)
library(scater)
library(readxl)
library(stringr)
library(SeuratExtend)
library(randomcoloR)

# Rise memory
options(future.globals.maxSize = 14000 * 1024^2) ## 14 GB (I think ...)
```

# 1. HTO Identification Results

## Task 1.1 Merge all samples

```{r}
# Gene Expression: This data matrix includes the gene expression counts per cell. It is the primary data used for most single-cell RNA-seq analyses, including cell type identification, differential expression analysis, clustering, and visualization (like UMAP).

# Multiplexing Capture: This generally refers to data generated from CITE-seq or Feature Barcoding technology, where antibodies tagged with oligonucleotides are used to capture protein expression. This data can be used to enrich the analysis by providing both gene and protein expression levels from the same cells. These measurements are highly useful for validating gene expression-based findings or for providing additional layers of data that might not be captured through RNA sequencing alone, such as post-translational modifications or actual protein levels.

# However, the protein data (from "Multiplexing Capture") is generally more sparse and less complex than gene expression data, which may affect some of the downstream analyses like dimension reduction and clustering. Certain steps, especially normalization and variable feature selection, might need to be adjusted due to the different data distribution.
```

```{r}
# List of sample names
sample_names <- c(
  # "Pool1_Mock_1_16_24h_A1",
  # "Pool1_Mock_1_16_24h_A2",
  # "Pool1_Mock_1_16_24h_A3",
  # "Pool1_Mock_1_16_24h_A4",
  "Pool2_Mock_1_16_48h_B1",
  "Pool2_Mock_1_16_48h_B2",
  "Pool2_Mock_1_16_48h_B3",
  "Pool2_Mock_1_16_48h_B4",
  "Pool3_Mock_1_16_72h_C1",
  "Pool3_Mock_1_16_72h_C2",
  "Pool3_Mock_1_16_72h_C3",
  "Pool3_Mock_1_16_72h_C4",
  # "Pool4_CAR_1_16_24h_D1",
  # "Pool4_CAR_1_16_24h_D2",
  # "Pool4_CAR_1_16_24h_D3",
  # "Pool4_CAR_1_16_24h_D4",
  "Pool5_CAR_1_16_48h_E1",
  "Pool5_CAR_1_16_48h_E2",
  "Pool5_CAR_1_16_48h_E3",
  "Pool5_CAR_1_16_48h_E4",
  "Pool6_CAR_1_16_72h_F1",
  "Pool6_CAR_1_16_72h_F2",
  "Pool6_CAR_1_16_72h_F3",
  "Pool6_CAR_1_16_72h_F4"
  # "Pool7_PDX1",
  # "Pool7_PDX3",
  # "Pool7_PDX4",
  # "Pool7_PDX5",
  # # "Pool8_PDX6",
  # "Pool8_PDX8",
  # "Pool8_PDX9",
  # "Pool8_PDX10"
)

# Create Seurat objects for the first dataset separately
first_sample <- sample_names[1]
first_file_path <- paste0("cellranger_multi_results_scRNAseq_697_B-ALL_resequenced/", first_sample, "/sample_filtered_feature_bc_matrix.h5")
first_data <- Read10X_h5(filename = first_file_path)
first_seurat_obj <- CreateSeuratObject(counts = first_data$`Gene Expression`, project = first_sample)
first_seurat_obj[['CMO']] = CreateAssayObject(counts = first_data$`Multiplexing Capture`)


# Create Seurat objects for the rest of the datasets
other_samples <- sample_names[-1]
seurat_objects <- list(first_seurat_obj)

# Loop through each other dataset name
for (sample_name in other_samples) {
  # Construct the file path
  file_path <- paste0("cellranger_multi_results_scRNAseq_697_B-ALL_resequenced/", sample_name, "/sample_filtered_feature_bc_matrix.h5")
  
  # Read the data
  data <- Read10X_h5(filename = file_path)
  
  # Create a Seurat object
  seurat_obj <- CreateSeuratObject(counts = data$`Gene Expression`, project = sample_name)
  seurat_obj[['CMO']] = CreateAssayObject(counts = data$`Multiplexing Capture`)
  
  # Store the Seurat object in the list
  seurat_objects[[sample_name]] <- seurat_obj
}

# Merge the Seurat objects
B_ALL_CAR.Object <- merge(x = first_seurat_obj, y = seurat_objects[-1], add.cell.id = sample_names)
```

```{r}
B_ALL_CAR.Object@assays
# rownames(B_ALL_CAR.Object@assays[["RNA"]])
```

```{r}
B_ALL_CAR.Object@meta.data
```

```{r}
# Add Metadata
# Compute Num of gene per UMI

B_ALL_CAR.Object$log10GenePerUMI = log10(B_ALL_CAR.Object$nFeature_RNA) / log10(B_ALL_CAR.Object$nCount_RNA)
```

```{r}
# Compute Percent mito ratio

B_ALL_CAR.Object$mitoPct = PercentageFeatureSet(B_ALL_CAR.Object, pattern = "^MT-")
B_ALL_CAR.Object$mitoRatio = B_ALL_CAR.Object@meta.data$mitoPct / 100
```

```{r}
B_ALL_CAR.Object@meta.data

# View(B_ALL_CAR.Object@meta.data)

```

# 2. Celltype Anchoring

```{r}
Task2_UMAP_before_filtering <- paste0(folder.name, "/Task2_UMAP_before_filtering")
  
if(!exists(Task2_UMAP_before_filtering)){
  dir.create(Task2_UMAP_before_filtering)
}
```

## Task 2.1 Add New Label Name

```{r}
# Define the mapping between old labels and new labels
mapping <- c(
  # "Pool1_Mock_1_16_24h_A1" = "WT_WT_Mock_24",
  # "Pool1_Mock_1_16_24h_A2" = "WT_KO_Mock_24",
  # "Pool1_Mock_1_16_24h_A3" = "KO_WT_Mock_24",
  # "Pool1_Mock_1_16_24h_A4" = "KO_KO_Mock_24",
  "Pool2_Mock_1_16_48h_B1" = "WT_WT_Mock_48",
  "Pool2_Mock_1_16_48h_B2" = "WT_KO_Mock_48",
  "Pool2_Mock_1_16_48h_B3" = "KO_WT_Mock_48",
  "Pool2_Mock_1_16_48h_B4" = "KO_KO_Mock_48",
  "Pool3_Mock_1_16_72h_C1" = "WT_WT_Mock_72",
  "Pool3_Mock_1_16_72h_C2" = "WT_KO_Mock_72",
  "Pool3_Mock_1_16_72h_C3" = "KO_WT_Mock_72",
  "Pool3_Mock_1_16_72h_C4" = "KO_KO_Mock_72",
  # "Pool4_CAR_1_16_24h_D1" = "WT_WT_CAR_24",
  # "Pool4_CAR_1_16_24h_D2" = "WT_KO_CAR_24",
  # "Pool4_CAR_1_16_24h_D3" = "KO_WT_CAR_24",
  # "Pool4_CAR_1_16_24h_D4" = "KO_KO_CAR_24",
  "Pool5_CAR_1_16_48h_E1" = "WT_WT_CAR_48",
  "Pool5_CAR_1_16_48h_E2" = "WT_KO_CAR_48",
  "Pool5_CAR_1_16_48h_E3" = "KO_WT_CAR_48",
  "Pool5_CAR_1_16_48h_E4" = "KO_KO_CAR_48",
  "Pool6_CAR_1_16_72h_F1" = "WT_WT_CAR_72",
  "Pool6_CAR_1_16_72h_F2" = "WT_KO_CAR_72",
  "Pool6_CAR_1_16_72h_F3" = "KO_WT_CAR_72",
  "Pool6_CAR_1_16_72h_F4" = "KO_KO_CAR_72"
)

# Apply the mapping to create the new_labels column in B_ALL_CAR.Object@meta.data
B_ALL_CAR.Object@meta.data$new_labels <- mapping[B_ALL_CAR.Object@meta.data$orig.ident]

# Move new_labels column right after orig.ident
B_ALL_CAR.Object@meta.data <- B_ALL_CAR.Object@meta.data[, c(1, ncol(B_ALL_CAR.Object@meta.data), 2:(ncol(B_ALL_CAR.Object@meta.data)-1))]

# Check for unmapped values in B_ALL_CAR.Object@meta.data
unmapped <- is.na(B_ALL_CAR.Object@meta.data$new_labels)
if (any(unmapped)) {
  cat("The following orig.ident values have no mapping and are set to NA:\n")
  cat(paste(B_ALL_CAR.Object@meta.data$orig.ident[unmapped], collapse = "\n"))
  # Optionally set a default value for unmapped entries
  # B_ALL_CAR.Object@meta.data$new_labels[unmapped] <- "DefaultValue"
}

B_ALL_CAR.Object@meta.data
```

# SAVE POINT

```{r}
save_point = paste0(folder.name, "/SAVE_POINT")

if(!exists(save_point)){
  dir.create(save_point, recursive = TRUE)
}
```

```{r}
# saveRDS(B_ALL_CAR.Object, file = paste0(save_point, "/B_ALL_CAR.Object_new_labels_only_48h_72h_SeuratV5.rds"))
```

```{r}
# B_ALL_CAR.Object <- readRDS(paste0(save_point, "/B_ALL_CAR.Object_new_labels_only_48h_72h_SeuratV5.rds"))
```

## Task 2.2 Produce a UMAP without a reference - new_labels

### Task 2.2.1 PCA

```{r}
# Use standard normalization

DefaultAssay(B_ALL_CAR.Object) <- 'RNA'
B_ALL_CAR.Object <- NormalizeData(B_ALL_CAR.Object) %>% 
  # FindVariableFeatures() can find 'variable features', genes that exhibit high variability in expression levels across different cells
  FindVariableFeatures() %>% 
  ScaleData() %>% 
  RunPCA()
```

```{r}
# Determine percent of variation associated with each PC
pct <- B_ALL_CAR.Object[["pca"]]@stdev / sum(B_ALL_CAR.Object[["pca"]]@stdev) * 100
# pct

# Calculate cumulative percents for each PC
cumu <- cumsum(pct)
# cumu

# Determine which PC exhibits cumulative percent greater than 90% and % variation associated with the PC as less than 5
co1 <- which(cumu > 90 & pct < 5)[1]
co1
```

```{r}
# Identifies the PC where the percent change in variation between consecutive PCs is less than 0.1%
co2 <- sort(which((pct[1:length(pct) - 1] - pct[2:length(pct)]) > 0.1), decreasing = T)[1] + 1
co2
```

```{r}
# Choose the minimum of these two metrics as the PCs covering the majority of the variation in the data.
pcs <- min(co1, co2)
pcs
```

```{r}
plot_df <- data.frame(pct = pct,
                      cumu = cumu,
                      rank = 1:length(pct))

plot_df

ggplot(plot_df, aes(cumu, pct, label = rank, color = rank > pcs)) +
  geom_text() +
  # geom_vline(xintercept = 75, color = "grey") +
  # geom_hline(yintercept = min(pct[pct > 5]), color = "grey") +
  theme_bw()

```

### Task 2.2.2 RunUMAP by Default

```{r}
# Default resolution: 0.8
B_ALL_CAR.Object <- B_ALL_CAR.Object %>%
  FindNeighbors(., dims = 1:pcs) %>%
  # Enable method = "igraph" to avoid casting large data to a dense matrix.
  FindClusters(., method = "igraph") %>%
  RunUMAP(.,
          dims = 1:40,
          # dims = 1:pcs,
          reduction = "pca",
          n.components = 3L)
``` 

```{r}
head(B_ALL_CAR.Object@meta.data)
```

# SAVE POINT

```{r}
# Save the merged Seurat object
# saveRDS(B_ALL_CAR.Object, file = paste0(save_point, "/B_ALL_CAR.Object_with_reduction_only_48h_72h_V5.rds"))
```

```{r}
# B_ALL_CAR.Object <- readRDS(paste0(save_point, "/B_ALL_CAR.Object_with_reduction_only_48h_72h_V5.rds"))
```

### Task 2.2.3 UMAP Plot - new_labels

```{r}
Task2.2_UMAP <- paste0(Task2_UMAP_before_filtering, "/Task2.2_UMAP_with_new_labels")
  
if(!exists(Task2.2_UMAP)){
  dir.create(Task2.2_UMAP)
}
```

```{r}
B_ALL_CAR.Object@meta.data

B_ALL_CAR.Object@meta.data %>%
    dplyr::count(new_labels)
```

```{r}
num_unique_labels <- B_ALL_CAR.Object@meta.data %>%
    summarize(num_labels = n_distinct(new_labels)) %>%
    pull(num_labels)

print(num_unique_labels)
```

```{r}
# Task 2.2.3.1 Generate Distinct Colors

sample_colors <- c( 
  "#000075","#004DFF","dodgerblue2","steelblue4",
  "#E31A1C","maroon","deeppink1",
  "green4","green1","#00FFFF",
  "#8200FF",
  "#FF7F00","gold1","#FFFF00",
  "gray70","#F0B98D"
)
# sample_colors <- c( 
#   "#000075","#004DFF","dodgerblue2","steelblue4", "#00B7FF",
#   "#E31A1C","maroon","#C20078","deeppink1",
#   "green4","green1","#00FFFF","#BBFF00",
#   "#6A3D9A","#8200FF",
#   "#FF7F00","gold1","#FFFF00",
#   "gray70","#F0B98D"
# )
sample_labels <- levels(as.factor(B_ALL_CAR.Object@meta.data$new_labels))
sample_colors <- setNames(sample_colors, sample_labels)
```

```{r}
#### Task 2.2.3.2 2D Plot -- new_labels 

set.seed(123)  # Set a seed for reproducibility

plot <- dittoDimPlot(B_ALL_CAR.Object,
             var = "new_labels",
             color.panel = sample_colors,  # Use our custom colors
             size = 0.4,
             # legend.show = FALSE,
             legend.size = 5,
             do.label = TRUE,
             opacity = 0.5,
             labels.size = 1.5,
             reduction.use = "umap",
             xlab = "UMAP 1",
             ylab = "UMAP 2",
             main = "UMAP for All Samples"
             )

# Modify the plot to change legend text size
plot <- plot + theme(legend.position = "bottom",
                     legend.text = element_text(size = 8),
                     legend.spacing.x = unit(1, 'cm'), # Adjust spacing
                     legend.spacing.y = unit(1, 'cm')) 

ggsave(filename = paste0(Task2.2_UMAP, "/2D_UMAP_with_new_labels.pdf"), 
       plot = plot, 
       width = 10,  
       height = 8)
```

```{r}
#### Task 2.2.3.3 Interactive Plot -- new_labels

# Extract UMAP data
umap_data <- Embeddings(B_ALL_CAR.Object, reduction = "umap")
# Extract metadata for hover information
# umap_metadata <- FetchData(B_ALL_CAR.Object, vars = c("new_labels", "predicted.id"))
umap_metadata <- FetchData(B_ALL_CAR.Object, vars = "new_labels")
# Combine UMAP data with metadata
umap_plot_data <- cbind(umap_data, umap_metadata)

umap_plot_data$new_labels <- as.factor(umap_plot_data$new_labels)
# umap_plot_data$predicted.id <- as.factor(umap_plot_data$predicted.id)
umap_plot_data_df <- as.data.frame(umap_plot_data)
```

```{r}
# Create an interactive plot
fig <- plot_ly(umap_plot_data_df, 
               x = ~umap_1, 
               y = ~umap_2, 
               type = 'scatter', 
               mode = 'markers',
               color = ~new_labels,
               colors = sample_colors,
               marker = list(size = 3, opacity = 0.5),               
               text = ~paste("Label:", new_labels),
               hoverinfo = 'text')

# Customize the layout
fig <- fig %>% layout(title = 'Interactive UMAP Plot',
                      xaxis = list(title = 'UMAP 1'),
                      yaxis = list(title = 'UMAP 2'),
                      legend = list(font = list(size = 12)))

saveWidget(fig, file = paste0(Task2.2_UMAP, "/Interactive_UMAP_with_new_labels.html"))
```

```{r}
#### Task 2.2.3.4 3D Plot -- new_labels

# Embeddings(object = B_ALL_CAR.Object, reduction = "umap")

UMAP.3D <-
  plot_ly(data = umap_plot_data_df,
    x = ~umap_1,
    y = ~umap_2,
    z = ~umap_3,
    color = ~new_labels,
    colors = sample_colors,
    type="scatter3d",
    mode="markers+text",
    marker = list(
    size = 2,  # Slightly larger markers
    opacity = 0.5  # Some transparency
  )
)

htmlwidgets::saveWidget(
  widget = UMAP.3D,
  file = paste0(Task2.2_UMAP, "/3D_UMAP_with_new_labels.html"),
  selfcontained = T,
  title = "3D UMAP"
)
```

## Task 2.3 Feature UMAP

```{r}
Task2.3_FeatureUMAP <- paste0(Task2_UMAP_before_filtering, "/Task2.3_FeatureUMAP")
  
if(!exists(Task2.3_FeatureUMAP)){
  dir.create(Task2.3_FeatureUMAP)
}
```

```{r}
genes <- c("CD19", "PAX5", "CD3D")

for (gene in genes) {
  pdf(paste0(Task2.3_FeatureUMAP, "/", gene, "_with_cutoff.pdf")) 
  p <- FeaturePlot(
    object = B_ALL_CAR.Object,
    features = gene,
    min.cutoff = "q10",  
    max.cutoff = "q90"   
  )
  print(p) 
  dev.off()
  print(p) 
}
```

## Task 2.4 Split into Individual Samples

```{r}
Task2.4_indUMAP <- paste0(Task2_UMAP_before_filtering, "/Task2.4_Individual_Sample_UMAP")
  
if(!exists(Task2.4_indUMAP)){
  dir.create(Task2.4_indUMAP)
}
```

```{r}
unique_labels <- unique(B_ALL_CAR.Object@meta.data$new_labels)

# # Store plot objects in a list
# plot_list <- list()

for (label in unique_labels) {
  # Extract data for plotting
  data <- FetchData(B_ALL_CAR.Object, vars = c("umap_1", "umap_2", "new_labels"))

  # Define the highlight condition directly in the data frame
  data$highlight <- ifelse(data$new_labels == label, 'highlighted', 'other')

  # Start a ggplot
  p <- ggplot(data, aes(x = umap_1, y = umap_2)) +
    geom_point(data = data[data$highlight == "other", ], aes(color = highlight), alpha = 0.5, size = 0.2) +
    geom_point(data = data[data$highlight == "highlighted", ], aes(color = highlight), size = 0.2) +
    scale_color_manual(values = c("other" = "grey", "highlighted" = "red")) +
    ggtitle(paste("UMAP Plot for", label)) +
    theme_minimal()

  pdf_filename <- paste0(Task2.4_indUMAP, "/UMAP_highlight_", label, ".pdf")
  
  pdf(pdf_filename, width = 8, height = 6)
  print(p)
  dev.off()
  
  # plot_list[[label]] <- p
}
```

```{r}
# # Split the Seurat object based on 'new_labels'
# split_objects <- SplitObject(B_ALL_CAR.Object, split.by = "new_labels")
# 
# # Loop through each subset, plot UMAP, and save as PDF
# for (label in names(split_objects)) {
#   # Generate the UMAP plot
#   p <- DimPlot(split_objects[[label]], reduction = "umap")
# 
#   file_path <- paste0(Task2.4_indUMAP, "/", label, "_UMAP.pdf")
#   
#   pdf(file_path)
#   print(p)  
#   dev.off() 
# }
```

## Task 2.5 bmcite Cell Annotation

```{r}
### Load Reference bmcite


# SeuratData::InstallData("bmcite")
bm <- LoadData(ds = "bmcite")
bm
```

```{r}
# The reference dataset contains a WNN graph, reflecting a weighted combination of the RNA and protein data in this CITE-seq experiment.

# We can compute a UMAP visualization based on this graph. We set return.model = TRUE, which will enable us to project query datasets onto this visualization.

bm <- RunUMAP(bm, nn.name = "weighted.nn", reduction.name = "wnn.umap", 
              reduction.key = "wnnUMAP_", return.model = TRUE)
DimPlot(bm, group.by = "celltype.l2", reduction = "wnn.umap") 
```

```{r}
## Compute an sPCA transformation


# As described in our manuscript, we first compute a ‘supervised’ PCA. This identifies the transformation of the transcriptome data that best encapsulates the structure of the WNN graph. This allows a weighted combination of the protein and RNA measurements to ‘supervise’ the PCA, and highlight the most relevant sources of variation. After computing this transformation, we can project it onto a query dataset. We can also compute and project a PCA projection, but recommend the use of sPCA when working with multimodal references that have been constructed with WNN analysis.

# The sPCA calculation is performed once, and then can be rapidly projected onto each query dataset.

bm <- ScaleData(bm, assay = 'RNA')
bm <- RunSPCA(bm, assay = 'RNA', graph = 'wsnn')
```

```{r}
## Compute a cached neighbor index


# Since we will be mapping multiple query samples to the same reference, we can cache particular steps that only involve the reference. This step is optional but will improve speed when mapping multiple samples.

# We compute the first 50 neighbors in the sPCA space of the reference. We store this information in the spca.annoy.neighbors object within the reference Seurat object and also cache the annoy index data structure (via cache.index = TRUE).

bm <- FindNeighbors(
  object = bm,
  reduction = "spca",
  dims = 1:50,
  graph.name = "spca.annoy.neighbors", 
  k.param = 50,
  cache.index = TRUE,
  return.neighbor = TRUE,
  l2.norm = TRUE
)
```

```{r}
## Query dataset preprocessing


# Here we will demonstrate mapping multiple donor bone marrow samples to the multimodal bone marrow reference. 
# We first split the data back into separate Seurat objects, one for each original donor to map individually.

# Batch Effects and Variability: Each donor's sample can have unique biological characteristics and technical variations. Now, you can address these variations more effectively.

B_ALL_CAR.Object.batches <- SplitObject(B_ALL_CAR.Object, split.by = "new_labels")
# B_ALL_CAR.Object.batches
```

```{r}
# We then normalize the query in the same manner as the reference. Here, the reference was normalized using log-normalization via NormalizeData(). If the reference had been normalized using SCTransform(), the query must be normalized with SCTransform() as well.

B_ALL_CAR.Object.batches <- lapply(X = B_ALL_CAR.Object.batches, FUN = NormalizeData, verbose = FALSE)
```

```{r}
## Mapping - Celltype Identification


# We then find anchors between each donor query dataset and the multimodal reference. This command is optimized to minimize mapping time, by passing in a pre-computed set of reference neighbors, and turning off anchor filtration.

anchors <- list()
for (i in 1:length(B_ALL_CAR.Object.batches)) {
  anchors[[i]] <- FindTransferAnchors(
    reference = bm,
    query = B_ALL_CAR.Object.batches[[i]],
    k.filter = NA,
    reference.reduction = "spca", 
    reference.neighbors = "spca.annoy.neighbors", 
    dims = 1:50
  )
}
```

```{r}
# We then individually map each of the datasets.

for (i in 1:length(B_ALL_CAR.Object.batches)) {
  B_ALL_CAR.Object.batches[[i]] <- MapQuery(
    anchorset = anchors[[i]], 
    query = B_ALL_CAR.Object.batches[[i]],
    reference = bm, 
    refdata = list(
      celltype = "celltype.l2", 
      predicted_ADT = "ADT"),
    reference.reduction = "spca",
    reduction.model = "wnn.umap"
  )
}
```

```{r}
# We can also merge all the objects into one dataset. Note that they have all been integrated into a common space, defined by the reference. We can then visualize the results together.

# Merge the batches
B_ALL_CAR.Object <- merge(B_ALL_CAR.Object.batches[[1]], B_ALL_CAR.Object.batches[2:length(B_ALL_CAR.Object.batches)], merge.dr = "umap")
```

### Task 2.5.1 Overall UMAP

```{r}
Task2.5_bm_Cellbype <- paste0(Task2_UMAP_before_filtering, "/Task2.5_bm_Cellbype_UMAP")
  
if(!exists(Task2.5_bm_Cellbype)){
  dir.create(Task2.5_bm_Cellbype)
}
```

```{r}
set.seed(123)
p <- DimPlot(B_ALL_CAR.Object, reduction = "umap", group.by =  "predicted.celltype", label = TRUE, repel = TRUE, label.size = 3) 
p <- p + theme(legend.text = element_text(size = 6))
p
filename <- "overall_UMAP_with_celltype.pdf"
path <- paste0(Task2.5_bm_Cellbype)
ggsave(filename = file.path(path, filename), plot = p, width = 10, height = 8)
```

```{r}
# Plot on bm-cite data

# set.seed(123)
# p <- DimPlot(B_ALL_CAR.Object, reduction = "ref.umap", group.by =  "predicted.celltype", label = TRUE, repel = TRUE, label.size = 3) 
# p <- p + theme(legend.text = element_text(size = 6))
# p
# filename <- "celltype_bmcite_ref_B_ALL_CAR_UMAP_Plot.pdf"
# path <- paste0(Task2.5_bm_Cellbype)
# ggsave(filename = file.path(path, filename), plot = p, width = 10, height = 8)
```

### Task 2.5.2 Individual UMAP with Cell Type

```{r}
Task2.5_bm_Cellbype_ind <- paste0(Task2.5_bm_Cellbype, "/Individual_Sample_UMAP_with_celltype")
  
if(!exists(Task2.5_bm_Cellbype_ind)){
  dir.create(Task2.5_bm_Cellbype_ind)
}
```

```{r}
# Get unique sample labels from new_labels
unique_labels <- unique(B_ALL_CAR.Object@meta.data$new_labels)

# Define a fixed color palette function for cell types using RColorBrewer
cell_types <- unique(B_ALL_CAR.Object@meta.data$predicted.celltype)
num_cell_types <- length(cell_types)

# Choose a palette with bright, distinct colors
getFixedColors <- function(n) {
  if (n <= 8) {
    return(brewer.pal(n, "Dark2")) # For up to 8 colors
  } else {
    return(colorRampPalette(brewer.pal(8, "Dark2"))(n)) # Extend if more colors are needed
  }
}

# Assign colors to each cell type
fixed_colors <- setNames(getFixedColors(num_cell_types), cell_types)

# Loop through each sample
for (label in unique_labels) {
  # Extract data for plotting
  data <- FetchData(B_ALL_CAR.Object, vars = c("umap_1", "umap_2", "new_labels", "predicted.celltype"))
  
  # Define the highlight condition directly in the data frame
  data$highlight <- ifelse(data$new_labels == label, 'highlighted', 'other')
  
  # Start a ggplot
  p <- ggplot() +
    # First, plot all other samples in grey
    geom_point(data = data[data$highlight == "other", ], aes(x = umap_1, y = umap_2), color = "grey", alpha = 0.3, size = 0.2) +
    # Next, plot the highlighted sample with fixed colors for different cell types
    geom_point(data = data[data$highlight == "highlighted", ], aes(x = umap_1, y = umap_2, color = predicted.celltype), size = 0.3) +
    # Use the predefined fixed colors
    scale_color_manual(values = fixed_colors) +
    ggtitle(paste("UMAP Plot Highlighting", label)) +
    theme_minimal() +
    theme(legend.title = element_text(size = 10), legend.text = element_text(size = 8))

  # Define the output filename for the current sample
  pdf_filename <- paste0(Task2.5_bm_Cellbype_ind, "/UMAP_highlight_", label, ".pdf")
  
  # Save the plot to a PDF file
  pdf(pdf_filename, width = 8, height = 6)
  print(p)
  dev.off()
}
```

```{r}
# # Only show interested samples:
# 
# library(RColorBrewer)
# 
# # Get unique sample labels from new_labels
# unique_samples <- unique(B_ALL_CAR.Object@meta.data$new_labels)
# 
# # Define a color palette function using RColorBrewer
# getDistinctColors <- function(n) {
#   if (n <= 12) {
#     return(brewer.pal(n, "Set3")) # Set3 has distinct colors
#   } else {
#     return(colorRampPalette(brewer.pal(12, "Set3"))(n))
#   }
# }
# 
# # Loop through each sample
# for (sample in unique_samples) {
#   
#   # Subset the data for the current sample
#   sample_data <- subset(B_ALL_CAR.Object, subset = new_labels == sample)
#   
#   # Extract UMAP coordinates and predicted cell types
#   data <- FetchData(sample_data, vars = c("umap_1", "umap_2", "predicted.celltype"))
#   
#   # Generate the UMAP plot for the current sample
#   p <- ggplot(data, aes(x = umap_1, y = umap_2, color = predicted.celltype)) +
#     geom_point(size = 0.2, alpha = 0.8) +
#     ggtitle(paste("UMAP Plot for Sample:", sample)) +
#     scale_color_manual(values = getDistinctColors(length(unique(data$predicted.celltype)))) +
#     theme_minimal() +
#     theme(legend.title = element_text(size = 10), legend.text = element_text(size = 8))
#   
#   # Define the output filename for the current sample
#   pdf_filename <- paste0(Task2.5_bm_Cellbype_ind, "/", "UMAP_", sample, ".pdf")
#   
#   # Save the plot to a PDF file
#   pdf(pdf_filename, width = 8, height = 6)
#   print(p)
#   dev.off()
# }
```

```{r}
# # Now that mapping is complete, we can visualize the results for individual objects
# # Split the Seurat object based on 'new_labels'
# 
# # Loop through each subset, plot UMAP, and save as PDF
# for (label in names(B_ALL_CAR.Object.batches)) {
#   # Generate the UMAP plot
#   p <- DimPlot(B_ALL_CAR.Object.batches[[label]], reduction = "umap", group.by = 'predicted.celltype', label.size = 3)
# 
#   file_path <- paste0(Task2.5_bm_Cellbype_ind, "/", label, "_UMAP.pdf")
#   
#   pdf(file_path)
#   print(p)  
#   dev.off() 
# }
```

# SAVE POINT

```{r}
# Save the merged Seurat object
# saveRDS(B_ALL_CAR.Object, file = paste0(save_point, "/B_ALL_CAR.Object_with_celltype_only_48h_72h_V5.rds"))
```

```{r}
# B_ALL_CAR.Object <- readRDS(paste0(save_point, "/B_ALL_CAR.Object_with_celltype_only_48h_72h_V5.rds"))
```

# 3. Manually modify clusters

## Task 3.1 For T Cell Cluster

### Task 3.1.1 Remove PAX5-expressing cells

```{r}
plot <- DimPlot(object = B_ALL_CAR.Object)
cells.located = CellSelector(plot = plot)
```

```{r}
B_ALL_CAR.Object_t_cell_cluster = B_ALL_CAR.Object[,cells.located]
```

```{r}
# B_ALL_CAR.Object_t_cell_cluster@meta.data
table(B_ALL_CAR.Object_t_cell_cluster@meta.data$predicted.celltype)
```

```{r}
pax5_positive_cells <- WhichCells(B_ALL_CAR.Object_t_cell_cluster, expression = PAX5 > 0)

# Remove PAX5-expressing cells
B_ALL_CAR.Object_t_cell_cluster.filtered <- subset(B_ALL_CAR.Object_t_cell_cluster, cells = setdiff(Cells(B_ALL_CAR.Object_t_cell_cluster), pax5_positive_cells))
```

```{r}
table(B_ALL_CAR.Object_t_cell_cluster.filtered@meta.data$predicted.celltype)
```

```{r}
set.seed(123)
p <- DimPlot(B_ALL_CAR.Object_t_cell_cluster.filtered, reduction = "umap", group.by =  "predicted.celltype", label = TRUE, repel = TRUE, label.size = 3) 
p <- p + theme(legend.text = element_text(size = 6))
p
```

### Task 3.1.2 Remove B Cells

```{r}
# Identify cells to remove based on predicted cell type
cell_types_to_remove_t <- c("Plasmablast", "Prog_B 1", "Prog_B 2", "Prog_RBC", "Prog_DC", "GMP")
cells_to_remove_t <- WhichCells(B_ALL_CAR.Object_t_cell_cluster.filtered, expression = predicted.celltype %in% cell_types_to_remove_t)

# Remove the specified cells based on cell type from the T cell cluster
B_ALL_CAR.Object_t_cell_cluster.filtered.final <- subset(B_ALL_CAR.Object_t_cell_cluster.filtered, cells = setdiff(Cells(B_ALL_CAR.Object_t_cell_cluster.filtered), cells_to_remove_t))
```

```{r}
set.seed(123)
p <- DimPlot(B_ALL_CAR.Object_t_cell_cluster.filtered.final, reduction = "umap", group.by =  "predicted.celltype", label = TRUE, repel = TRUE, label.size = 3) 
p <- p + theme(legend.text = element_text(size = 6))
p
```

### Task 3.1.3  Remove from the Original Seurat Object

```{r}
# Remove the specified cells from the original Seurat object
B_ALL_CAR.Object_t_cell_cluster.filtered.final.all <- subset(B_ALL_CAR.Object, cells = setdiff(Cells(B_ALL_CAR.Object), pax5_positive_cells))

B_ALL_CAR.Object_t_cell_cluster.filtered.final.all <- subset(B_ALL_CAR.Object_t_cell_cluster.filtered.final.all, cells = setdiff(Cells(B_ALL_CAR.Object_t_cell_cluster.filtered.final.all), cells_to_remove_t))
```

```{r}
set.seed(123)
p <- DimPlot(B_ALL_CAR.Object_t_cell_cluster.filtered.final.all, reduction = "umap", group.by =  "predicted.celltype", label = TRUE, repel = TRUE, label.size = 3) 
p <- p + theme(legend.text = element_text(size = 6))
p
```

```{r}
genes <- c("CD19", "PAX5", "CD3D")

for (gene in genes) {
  p <- FeaturePlot(
    object = B_ALL_CAR.Object_t_cell_cluster.filtered.final.all,
    features = gene,
    min.cutoff = "q10",  
    max.cutoff = "q90" 
  )
  print(p) 
}
```

## Task 3.2 For B-ALL Clusters

### Task 3.2.1 Remove CD3D-expressing cells 

```{r}
plot <- DimPlot(object = B_ALL_CAR.Object)
cells.located = CellSelector(plot = plot)
```

```{r}
B_ALL_CAR.Object_B_ALL_cluster = B_ALL_CAR.Object[,cells.located]
```

```{r}
# B_ALL_CAR.Object_B_ALL_cluster@meta.data
table(B_ALL_CAR.Object_B_ALL_cluster@meta.data$predicted.celltype)
```

```{r}
cd3d_positive_cells <- WhichCells(B_ALL_CAR.Object_B_ALL_cluster, expression = CD3D > 0)

# Remove CD3D-expressing cells
B_ALL_CAR.Object_B_ALL_cluster.filtered <- subset(B_ALL_CAR.Object_B_ALL_cluster, cells = setdiff(Cells(B_ALL_CAR.Object_B_ALL_cluster), cd3d_positive_cells))
```

```{r}
table(B_ALL_CAR.Object_B_ALL_cluster.filtered@meta.data$predicted.celltype)
```

```{r}
set.seed(123)
p <- DimPlot(B_ALL_CAR.Object_B_ALL_cluster.filtered, reduction = "umap", group.by =  "predicted.celltype", label = TRUE, repel = TRUE, label.size = 3) 
p <- p + theme(legend.text = element_text(size = 6))
p
```

### Task 3.2.2 Remove T cells from B-ALL clusters

```{r}
# Identify cells to remove based on predicted cell type
cell_types_to_remove_b <- c("CD4 Memory", "CD4 Naive", "CD8 Memory_2", "Treg")
cells_to_remove_b <- WhichCells(B_ALL_CAR.Object_B_ALL_cluster.filtered, expression = predicted.celltype %in% cell_types_to_remove_b)

# Remove the specified cells based on cell type from the T cell cluster
B_ALL_CAR.Object_B_ALL_cluster.filtered.final <- subset(B_ALL_CAR.Object_B_ALL_cluster.filtered, cells = setdiff(Cells(B_ALL_CAR.Object_B_ALL_cluster.filtered), cells_to_remove_b))
```

```{r}
set.seed(123)
p <- DimPlot(B_ALL_CAR.Object_B_ALL_cluster.filtered.final, reduction = "umap", group.by =  "predicted.celltype", label = TRUE, repel = TRUE, label.size = 3) 
p <- p + theme(legend.text = element_text(size = 6))
p
```

### Task 3.2.3 Remove from the Original Seurat Object

```{r}
# Remove the specified cells from the original Seurat object
B_ALL_CAR.Object_B_ALL_cluster.filtered.final.all <- subset(B_ALL_CAR.Object_t_cell_cluster.filtered.final.all, cells = setdiff(Cells(B_ALL_CAR.Object_t_cell_cluster.filtered.final.all), cd3d_positive_cells))

B_ALL_CAR.Object_B_ALL_cluster.filtered.final.all <- subset(B_ALL_CAR.Object_B_ALL_cluster.filtered.final.all, cells = setdiff(Cells(B_ALL_CAR.Object_B_ALL_cluster.filtered.final.all), cells_to_remove_b))
```

```{r}
B_ALL_CAR.final.all <- B_ALL_CAR.Object_B_ALL_cluster.filtered.final.all

set.seed(123)
p <- DimPlot(B_ALL_CAR.final.all, reduction = "umap", group.by =  "predicted.celltype", label = TRUE, repel = TRUE, label.size = 3) 
p <- p + theme(legend.text = element_text(size = 6))
p
```

```{r}
genes <- c("CD19", "PAX5", "CD3D")

for (gene in genes) {
  p <- FeaturePlot(
    object = B_ALL_CAR.final.all,
    features = gene,
    min.cutoff = "q10",  
    max.cutoff = "q90" 
  )
  print(p) 
}
```

# SAVE POINT

```{r}
# saveRDS(B_ALL_CAR.final.all, file = paste0(save_point, "/B_ALL_CAR.Object_with_celltype_only_48h_72h_filtered_final_SeuratV5.rds"))
```

```{r}
# B_ALL_CAR.final.all <- readRDS(paste0(save_point, "/B_ALL_CAR.Object_with_celltype_only_48h_72h_filtered_final_SeuratV5.rds"))
```

### Task 3.3 Re-run UMAP

```{r}
B_ALL_CAR.final.all.rerun <- B_ALL_CAR.final.all
```

```{r}
DefaultAssay(B_ALL_CAR.final.all.rerun) <- 'RNA'
B_ALL_CAR.final.all.rerun <- NormalizeData(B_ALL_CAR.final.all.rerun) %>% 
  FindVariableFeatures() %>% 
  ScaleData() %>% 
  RunPCA()
```

```{r}
# Determine percent of variation associated with each PC
pct <- B_ALL_CAR.final.all.rerun[["pca"]]@stdev / sum(B_ALL_CAR.final.all.rerun[["pca"]]@stdev) * 100
# pct

# Calculate cumulative percents for each PC
cumu <- cumsum(pct)
# cumu

# Determine which PC exhibits cumulative percent greater than 90% and % variation associated with the PC as less than 5
co1 <- which(cumu > 90 & pct < 5)[1]
co1
```

```{r}
# Identifies the PC where the percent change in variation between consecutive PCs is less than 0.1%
co2 <- sort(which((pct[1:length(pct) - 1] - pct[2:length(pct)]) > 0.1), decreasing = T)[1] + 1
co2
```

```{r}
# Choose the minimum of these two metrics as the PCs covering the majority of the variation in the data.
pcs <- min(co1, co2)
pcs
```

```{r}
# Default resolution: 0.8
B_ALL_CAR.final.all.rerun <- B_ALL_CAR.final.all.rerun %>%
  FindNeighbors(., dims = 1:pcs) %>%
  # Enable method = "igraph" to avoid casting large data to a dense matrix.
  FindClusters(., method = "igraph") %>%
  RunUMAP(.,
          dims = 1:40,
          # dims = 1:pcs,
          reduction = "pca",
          n.components = 3L)
``` 

```{r}
set.seed(123)
p <- DimPlot(B_ALL_CAR.final.all.rerun, reduction = "umap", group.by =  "predicted.celltype", label = TRUE, repel = TRUE, label.size = 3) 
p <- p + theme(legend.text = element_text(size = 6))
p
```

# SAVE POINT

```{r}
# saveRDS(B_ALL_CAR.final.all.rerun, file = paste0(save_point, "/B_ALL_CAR.Object_with_celltype_only_48h_72h_filtered_final_rerun_SeuratV5.rds"))
```

```{r}
# B_ALL_CAR.final.all.rerun <- readRDS(paste0(save_point, "/B_ALL_CAR.Object_with_celltype_only_48h_72h_filtered_final_rerun_SeuratV5.rds"))
```

## Task 3.4 Generate UMAPS

```{r}
Task3.4_UMAP_after_filter <- paste0(folder.name, "/Task3.4_UMAP_after_filtering")
  
if(!exists(Task3.4_UMAP_after_filter)){
  dir.create(Task3.4_UMAP_after_filter)
}
```

```{r}
set.seed(123)
p <- DimPlot(B_ALL_CAR.final.all.rerun, reduction = "umap", group.by =  "predicted.celltype", label = TRUE, repel = TRUE, label.size = 2) 
p <- p + theme(legend.text = element_text(size = 6))
p <- p + ggtitle("UMAP After Manually Filtering")
p
filename <- "overall_UMAP_after_filtering_with_celltype.pdf"
path <- paste0(Task3.4_UMAP_after_filter)
ggsave(filename = file.path(path, filename), plot = p, width = 10, height = 8)
```

```{r}
genes <- c("CD19", "PAX5", "CD3D")

for (gene in genes) {
  pdf(paste0(Task3.4_UMAP_after_filter, "/", gene, "_with_cutoff.pdf")) 
  p <- FeaturePlot(
    object = B_ALL_CAR.final.all.rerun,
    features = gene,
    min.cutoff = "q10",  
    max.cutoff = "q90"   
  )
  print(p) 
  dev.off()
  print(p) 
}
```

```{r}
plot <- DimPlot(object = B_ALL_CAR.final.all.rerun)
cells.located = CellSelector(plot = plot)
```

```{r}
seurat_object_t = B_ALL_CAR.final.all.rerun[,cells.located]
```

```{r}
set.seed(123)
p <- DimPlot(seurat_object_t, reduction = "umap", group.by =  "predicted.celltype", label = TRUE, repel = TRUE, label.size = 3) 
p <- p + theme(legend.text = element_text(size = 6))
p <- p + ggtitle("UMAP of T-Cell Clusters Predicted Cell Types")
p
filename <- "UMAP_T-Cell_Cluster_after_filtering_with_celltype.pdf"
path <- paste0(Task3.4_UMAP_after_filter)
ggsave(filename = file.path(path, filename), plot = p, width = 10, height = 8)
```

```{r}
plot <- DimPlot(object = B_ALL_CAR.final.all.rerun)
cells.located = CellSelector(plot = plot)
```

```{r}
seurat_object_b = B_ALL_CAR.final.all.rerun[,cells.located]
```

```{r}
set.seed(123)
p <- DimPlot(seurat_object_b, reduction = "umap", group.by =  "predicted.celltype", label = TRUE, repel = TRUE, label.size = 3) 
p <- p + theme(legend.text = element_text(size = 6))
p <- p + ggtitle("UMAP of B-ALL Clusters Predicted Cell Types")
p
filename <- "UMAP_B-ALL_Clusters_after_filtering_with_celltype.pdf"
path <- paste0(Task3.4_UMAP_after_filter)
ggsave(filename = file.path(path, filename), plot = p, width = 10, height = 8)
```

```{r}
plot <- DimPlot(object = B_ALL_CAR.final.all.rerun)
cells.located = CellSelector(plot = plot)
```

```{r}
seurat_object_b_cluster1 = B_ALL_CAR.final.all.rerun[,cells.located]
```

```{r}
set.seed(123)
p <- DimPlot(seurat_object_b_cluster1, reduction = "umap", group.by =  "predicted.celltype", label = TRUE, repel = TRUE, label.size = 3) 
p <- p + theme(legend.text = element_text(size = 6))
p <- p + ggtitle("UMAP of B-ALL Cluster1 Predicted Cell Types")  # Adding a title
p
filename <- "UMAP_B-ALL_Cluster1_after_filtering_with_celltype.pdf"
path <- paste0(Task3.4_UMAP_after_filter)
ggsave(filename = file.path(path, filename), plot = p, width = 10, height = 8)
```

```{r}
plot <- DimPlot(object = B_ALL_CAR.final.all.rerun)
cells.located = CellSelector(plot = plot)
```

```{r}
seurat_object_b_cluster2 = B_ALL_CAR.final.all.rerun[,cells.located]
```

```{r}
set.seed(123)
p <- DimPlot(seurat_object_b_cluster2, reduction = "umap", group.by =  "predicted.celltype", label = TRUE, repel = TRUE, label.size = 3) 
p <- p + theme(legend.text = element_text(size = 6))
p <- p + ggtitle("UMAP of B-ALL Cluster2 Predicted Cell Types")  # Adding a title
p
filename <- "UMAP_B-ALL_Cluster2_after_filtering_with_celltype.pdf"
path <- paste0(Task3.4_UMAP_after_filter)
ggsave(filename = file.path(path, filename), plot = p, width = 10, height = 8)
```

# SAVE POINT

```{r}
# saveRDS(seurat_object_t, file = paste0(save_point, "/T_cluster_final_rerun.rds"))
# 
# saveRDS(seurat_object_b, file = paste0(save_point, "/B-ALL_clusters_final_rerun.rds"))
```

```{r}
# seurat_object_t <- readRDS(paste0(save_point, "/T_cluster_final_rerun.rds"))
# 
# seurat_object_b <- readRDS(paste0(save_point, "/B-ALL_clusters_final_rerun.rds"))
```

# 4. Analysis for T Cells 

```{r}
Task4_T_Cell_Plots <- paste0(folder.name, "/Task4_T-Cell_Plots")
  
if(!exists(Task4_T_Cell_Plots)){
  dir.create(Task4_T_Cell_Plots)
}
```

## Task 4.1 Bar Plot -- proportion of cell types

```{r}
seurat_object_t@meta.data
```

```{r}
table(seurat_object_t@meta.data$new_labels)
```

```{r}
metadata_t <- seurat_object_t@meta.data

# Define the custom order for the samples
sample_order <- c(
  "WT_WT_Mock_48", "WT_WT_Mock_72", "WT_WT_CAR_48", "WT_WT_CAR_72", 
  "WT_KO_Mock_48", "WT_KO_Mock_72", "WT_KO_CAR_48", "WT_KO_CAR_72",
  "KO_WT_Mock_48", "KO_WT_Mock_72", "KO_WT_CAR_48", "KO_WT_CAR_72",
  "KO_KO_Mock_48", "KO_KO_Mock_72", "KO_KO_CAR_48", "KO_KO_CAR_72"
)

# Calculate proportions of each cell type within each group
data_to_plot <- metadata_t %>%
  group_by(new_labels, predicted.celltype) %>%
  summarise(Count = n(), .groups = 'drop') %>%
  mutate(Total = sum(Count), Proportion = Count / Total) %>% 
  # Set the factor levels to control plot order
  mutate(new_labels = factor(new_labels, levels = sample_order))

p <- ggplot(data_to_plot, aes(x = new_labels, y = Proportion, fill = predicted.celltype)) +
  geom_bar(stat = "identity", position = "fill") +
  theme_minimal() +
  labs(x = "Samples", y = "Proportion", fill = "Cell Type", title = "Proportion of Cell Types within the T Cells Cluster") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
p

filename <- "Proportion_of_Cell_Types_within_the_T-Cells_Cluster.pdf"
path <- paste0(Task4_T_Cell_Plots)
ggsave(filename = file.path(path, filename), plot = p, width = 10, height = 8)
```

## Task 4.2 Bar Plots - Expression of Genes

```{r}
# Extract the expression data for the genes of interest
genes_of_interest <- c("GZMB", "PDCD1", "CD4", "CD8B", "IL7R")
expression_data <- FetchData(seurat_object_t, vars = genes_of_interest)

# Combine expression data with metadata
expression_data <- cbind(expression_data, seurat_object_t@meta.data$new_labels) %>% 
    rename(new_labels = `seurat_object_t@meta.data$new_labels`)

# Calculate the average expression for each gene within each group
average_expression <- expression_data %>%
  group_by(new_labels) %>%
  summarise(across(all_of(genes_of_interest), ~ mean(., na.rm = TRUE)))

# Reshape the data for plotting
average_expression_long <- pivot_longer(average_expression, cols = -new_labels, names_to = "Gene", values_to = "Expression")
```

```{r}
plots <- list()

# Iterate over each gene to create separate plots
for (gene in genes_of_interest) {
  # Filter the long format data for the current gene
  gene_data <- average_expression_long %>% filter(Gene == gene) %>% 
  # Set the factor levels to control plot order
  mutate(new_labels = factor(new_labels, levels = sample_order))
  
  p <- ggplot(gene_data, aes(x = new_labels, y = Expression, fill = new_labels)) +
    geom_bar(stat = "identity", position = position_dodge()) +
    geom_text(aes(label = round(Expression, 3)), vjust = -0.5, position = position_dodge(width = 0.9), color = "black", size = 3) + 
    theme_minimal() +
    labs(title = paste("Expression of", gene),
         x = "Samples",
         y = "Average Expression") +
    theme(axis.text.x = element_text(angle = 45, hjust = 1), legend.position = "none")  # Hide legend
  
  # Store the plot in the list
  plots[[gene]] <- p
}

for (gene in names(plots)) {
  pdf_path <- paste0(Task4_T_Cell_Plots, "/Expression_of_", gene, ".pdf")
  pdf(pdf_path, width = 10, height = 8) 
  print(plots[[gene]]) 
  dev.off()
  print(plots[[gene]])
}
```

# 5. Analysis for B-ALL Cells 

```{r}
Task5_B_ALL_Cell_Plots <- paste0(folder.name, "/Task5_B-ALL_Cluster_Plots")
  
if(!exists(Task5_B_ALL_Cell_Plots)){
  dir.create(Task5_B_ALL_Cell_Plots)
}
```

## Task 5.1 Cluster 1 vs. Cluster 2

```{r}
Task5.1_Cluster1_vs_Cluster2 <- paste0(Task5_B_ALL_Cell_Plots, "/Task5.1_Cluster1_vs_Cluster2")
  
if(!exists(Task5.1_Cluster1_vs_Cluster2)){
  dir.create(Task5.1_Cluster1_vs_Cluster2)
}
```

### Task 5.1.1 DE gene analysis

```{r}
Task5.1.1_DE_genes <- paste0(Task5.1_Cluster1_vs_Cluster2, "/Task5.1.1_DE_genes")
  
if(!exists(Task5.1.1_DE_genes)){
  dir.create(Task5.1.1_DE_genes)
}
```

```{r}
# head(Idents(seurat_object_b))

plot <- DimPlot(object = seurat_object_b)
cells.located_cluster_1 = CellSelector(plot = plot)
```

```{r}
# Assign a new identity to selected cells
Idents(seurat_object_b, cells = cells.located_cluster_1) <- "Cluster_1"
```

```{r}
# Idents(seurat_object_b)
# cells_cluster_1 <- WhichCells(object = seurat_object_b, idents = "Cluster_1")
# subset_cluster_1 <- subset(x = seurat_object_b, idents = "Cluster_1")
```

```{r}
plot <- DimPlot(object = seurat_object_b)
cells.located_cluster_2 = CellSelector(plot = plot)
```

```{r}
# Assign a new identity to selected cells
Idents(seurat_object_b, cells = cells.located_cluster_2) <- "Cluster_2"
```

```{r}
# Idents(seurat_object_b)
# cells_cluster_2 <- WhichCells(object = seurat_object_b, idents = "Cluster_2")
# subset_cluster_2 <- subset(x = seurat_object_b, idents = "Cluster_2")
```

```{r}
table(Idents(seurat_object_b))
```

```{r}
names(seurat_object_b)
```

```{r}
seurat_object_b <- JoinLayers(seurat_object_b)
seurat_object_b
```

```{r}
markers <- FindMarkers(seurat_object_b, ident.1 = "Cluster_1", ident.2 = "Cluster_2", logfc.threshold = 0.25, min.pct = 0.1)
```

```{r}
head(markers)
```

```{r}
# Summarize top markers
top_markers <- markers %>%
  arrange(p_val_adj) %>%
  head(n = 20)

top_markers
```

# SAVE POINT

```{r}
write.csv(markers, paste0(Task5.1.1_DE_genes, "/marker_results.csv"), row.names = TRUE)
write.csv(top_markers, paste0(Task5.1.1_DE_genes, "/top_marker_results.csv"), row.names = TRUE)

markers <- read.csv(paste0(Task5.1.1_DE_genes, "/marker_results.csv"), row.names = 1)
```

```{r}
# saveRDS(seurat_object_b, file = paste0(save_point, "/B-ALL_clusters_final_rerun_Cluster1and2.rds"))

# seurat_object_b <- readRDS(paste0(save_point, "/B-ALL_clusters_final_rerun_Cluster1and2.rds"))
```

### Task 5.1.2 GSEA Hallmarks analysis 

```{r}
Task5.1.2_GSEA_Hallmark_results <- paste0(Task5.1_Cluster1_vs_Cluster2, "/Task5.1.2_GSEA_Hallmark_results")
if(!dir.exists(Task5.1.2_GSEA_Hallmark_results)) {
  dir.create(Task5.1.2_GSEA_Hallmark_results, recursive = TRUE)
}
```

```{r}
msigdbr.Hallmark.df = msigdbr(species = "Homo sapiens", category = "H")
msigdbr.Hallmark.df
```

```{r}
fgsea_hallmark_sets = msigdbr.Hallmark.df %>% 
  # mutate(gs_name = str_remove(gs_name, "HALLMARK_")) %>% 
  split(x = .$gene_symbol, f = .$gs_name)

length(names(fgsea_hallmark_sets))
```

```{r}
markers_to_rank <- markers
markers_to_rank$gene_symbol <- rownames(markers_to_rank)
markers_to_rank
```

```{r}
# Rank genes
# Genes with the highest positive log fold changes are ranked at the top, and genes with the highest negative log fold changes are ranked at the bottom.

markers_to_rank |>
  dplyr::select(gene_symbol, avg_log2FC) |>
  arrange(desc(avg_log2FC)) |>
  deframe() -> ranks
```

```{r}
# The enrichment scores will be calculated based on the ranks to assess whether gene sets are enriched toward the top or bottom of the ranked list
fgseaRes = fgsea(fgsea_hallmark_sets, stats = ranks)

# In practical terms, if log2err is set to NA for certain pathways, it implies that the confidence in the P-values for those pathways is lower, and they might have been overestimated. This typically happens when there aren't enough permutations or when pathway sizes are too small to yield a robust estimation of P-values.
```

```{r}
# Positive NES: Indicates that the gene set is enriched in Cluster 1 relative to Cluster 2.
# Negative NES: Indicates that the gene set is enriched in Cluster 2 relative to Cluster 1.
# Significant p-values/FDR: Highlight the most robustly enriched pathways.

fgseaResTidy = fgseaRes %>%
    mutate(abbrev_pathway = abbreviate(pathway)) |> 
    relocate(abbrev_pathway, .after = pathway) |> 
    as_tibble() %>%
    arrange(desc(NES))

  write_csv(fgseaResTidy, file = paste0(Task5.1.2_GSEA_Hallmark_results, "/GSEA_HALLMARK_B-ALL_Cluster1_versus_Cluster2.csv"))
  
  # only plot the top 40 pathways
  fgseaResTidy %>%
    mutate(NES2 = ifelse(NES>0, "Enriched in Cluster1", "Enriched in Cluster2")) %>%
    # mutate(pathway = abbreviate(pathway)) |> 
    # dplyr::filter(padj < 0.05) %>%
    dplyr::filter(pval < 0.05) %>%
    arrange(desc(NES)) %>%
    head(n = 40) -> GSEA.plot.data
  
  # Output plot data to CSV
  GSEA.plot.data %>% 
    mutate(Lead_size = as.integer(map(leadingEdge, length))) %>% 
    mutate(Lead_Genes = as.character(map(leadingEdge, paste0, collapse = ","))) %>%
    dplyr::select(-c(leadingEdge, NES2, size)) %>% 
    write_csv(file = paste0(Task5.1.2_GSEA_Hallmark_results, "/GSEA_HALLMARK_Plot_data_B-ALL_Cluster1_versus_Cluster2.csv"))

  # Column Plot
  cols = c("Enriched in Cluster1" = "green", "Enriched in Cluster2" = "red")
  
  GSEA.plot.data %>% 
    ggplot(aes(fct_reorder(pathway, NES), NES)) +
      geom_col(aes(fill= NES2)) +
      scale_fill_manual("NES", values = cols) +
      coord_flip() + 
      theme(axis.text.y = element_text(size = 6)) +
      labs(x="Pathway", y="Normalized Enrichment Score",
           title=paste0("B-ALL_Cluster1_versus_Cluster2")) 
  
    ggsave(filename = paste0(Task5.1.2_GSEA_Hallmark_results, "/GSEA_HALLMARK_B-ALL_Cluster1_versus_Cluster2.pdf"))
  
```

```{r}
# Top 10 Pathways for positive and negative pathways

fgseaResTidy %>%
  mutate(NES2 = ifelse(NES > 0, "Enriched in Cluster1", "Enriched in Cluster2")) %>%
  # Splitting the data into positive and negative NES pathways and selecting top 10 by smallest p-values
  group_by(NES2) %>%
  # filter(pval < 0.05) %>%
  arrange(pval) %>%
  slice_head(n = 10) %>%
  ungroup() %>%
  # Combining top positive and negative pathways
  bind_rows() %>%
  arrange(desc(NES)) -> GSEA.plot.data.pos_and_neg

# Output plot data to CSV
GSEA.plot.data.pos_and_neg %>% 
    mutate(Lead_size = as.integer(map(leadingEdge, length))) %>% 
    mutate(Lead_Genes = as.character(map(leadingEdge, paste0, collapse = ","))) %>%
    dplyr::select(-c(leadingEdge, NES2, size)) %>% 
    write_csv(file = paste0(Task5.1.2_GSEA_Hallmark_results, "/GSEA_HALLMARK_Plot_data_B-ALL_Cluster1_versus_Cluster2_pos_and_neg_top.csv"))

# Column Plot
cols = c("Enriched in Cluster1" = "green", "Enriched in Cluster2" = "red")
  
GSEA.plot.data.pos_and_neg %>% 
    ggplot(aes(fct_reorder(pathway, NES), NES)) +
      geom_col(aes(fill= NES2)) +
      scale_fill_manual("NES", values = cols) +
      # scale_fill_discrete(labels=c("Positive", "Negative")) +
      coord_flip() + 
      theme(axis.text.y = element_text(size = 6)) +
      labs(x="Pathway", y="Normalized Enrichment Score",
           title=paste0("B-ALL_Cluster1_versus_Cluster2_top10")) 
  
ggsave(filename = paste0(Task5.1.2_GSEA_Hallmark_results, "/GSEA_HALLMARK_B-ALL_Cluster1_versus_Cluster2_pos_and_neg_top.pdf"))
```

### Task 5.1.3 Two gene expression csv files for all samples

```{r}
Task5.1.3_Gene_expression_for_all_samples <- paste0(Task5.1_Cluster1_vs_Cluster2, "/Task5.1.3_Gene_expression_for_all_samples")
  
if(!exists(Task5.1.3_Gene_expression_for_all_samples)){
  dir.create(Task5.1.3_Gene_expression_for_all_samples)
}
```

```{r}
# seurat_object_b <- readRDS(paste0(save_point, "/B-ALL_clusters_final_rerun_Cluster1and2.rds"))

sample_order <- c(
  "WT_WT_Mock_48", "WT_WT_Mock_72", "WT_WT_CAR_48", "WT_WT_CAR_72", 
  "WT_KO_Mock_48", "WT_KO_Mock_72", "WT_KO_CAR_48", "WT_KO_CAR_72",
  "KO_WT_Mock_48", "KO_WT_Mock_72", "KO_WT_CAR_48", "KO_WT_CAR_72",
  "KO_KO_Mock_48", "KO_KO_Mock_72", "KO_KO_CAR_48", "KO_KO_CAR_72"
)

# Replace underscores with hyphens
sample_order <- gsub("_", "-", sample_order)

# Function to calculate average expression per sample and cluster
calculate_average_expression <- function(seurat_obj, cluster) {
  # Subset by cluster
  subset_cluster <- subset(seurat_obj, idents = cluster)

  # Calculate average expression
  avg_expression <- AverageExpression(subset_cluster, group.by = "new_labels", return.seurat = FALSE)$RNA
  
  avg_expression <- avg_expression[, sample_order]
}

# Calculate average expression for Cluster 1 and Cluster 2
### already normalized by log1p which is log(UMI + 1), but log(1) = 0, so there still many 0s.
avg_exp_cluster1 <- calculate_average_expression(seurat_object_b, "Cluster_1")
avg_exp_cluster2 <- calculate_average_expression(seurat_object_b, "Cluster_2")

avg_exp_cluster1 <- as.matrix(avg_exp_cluster1)
avg_exp_cluster2 <- as.matrix(avg_exp_cluster2)

# Save to CSV
write.csv(avg_exp_cluster1, paste0(Task5.1.3_Gene_expression_for_all_samples, "/avg_exp_cluster1.csv"), row.names = TRUE)
write.csv(avg_exp_cluster2, paste0(Task5.1.3_Gene_expression_for_all_samples, "/avg_exp_cluster2.csv"), row.names = TRUE)
```

### Task 5.1.4 Violin Plots for some genes

```{r}
Task5.1.4_Violin_plot_for_some_genes <- paste0(Task5.1_Cluster1_vs_Cluster2, "/Task5.1.4_Violin_plot_for_some_genes")
  
if(!exists(Task5.1.4_Violin_plot_for_some_genes)){
  dir.create(Task5.1.4_Violin_plot_for_some_genes)
}
```

```{r}
table(Idents(seurat_object_b))
```

```{r}
# List of genes to plot
genes_to_plot <- c("RELA", "TP53", "MDM2", "BAX", "CD19", "GADD45A", "BCL2L11", "SLC27A2")

sample_order <- c(
  "WT_WT_Mock_48", "WT_WT_Mock_72", "WT_WT_CAR_48", "WT_WT_CAR_72", 
  "WT_KO_Mock_48", "WT_KO_Mock_72", "WT_KO_CAR_48", "WT_KO_CAR_72",
  "KO_WT_Mock_48", "KO_WT_Mock_72", "KO_WT_CAR_48", "KO_WT_CAR_72",
  "KO_KO_Mock_48", "KO_KO_Mock_72", "KO_KO_CAR_48", "KO_KO_CAR_72",
  "Pool7_PDX1", "Pool7_PDX3", "Pool7_PDX4", "Pool7_PDX5",
  "Pool8_PDX8", "Pool8_PDX9", "Pool8_PDX10" = "Pool8_PDX10"
)
```

```{r}
base_dir <- Task5.1.4_Violin_plot_for_some_genes

for (cluster in c("Cluster_1", "Cluster_2")) {
  plot_list <- list()
  
  cluster_data <- subset(seurat_object_b, idents = cluster)
  cluster_dir <- paste0(base_dir, "/", cluster)
  if (!dir.exists(cluster_dir)) {
    dir.create(cluster_dir, recursive = TRUE)
  }
  
  for (gene in genes_to_plot) {
    
    gene_data <- FetchData(cluster_data, vars = gene)
    gene_data$new_labels <- cluster_data@meta.data$new_labels
    
    filtered_data <- gene_data[gene_data[[gene]] > 0, ]

    filtered_data$new_labels <- factor(
      filtered_data$new_labels, 
      levels = sample_order
    )

    p <- ggplot(filtered_data, aes(x = new_labels, y = !!sym(gene), fill = as.factor((as.integer(new_labels) - 1) %/% 2))) +
        geom_violin(trim = TRUE) +
        stat_summary(fun = mean, geom = "errorbar", width = 0.2, 
                 color = "black", size = 0.5, linetype = "solid",
                 aes(ymin = ..y.., ymax = ..y..)) + 
        scale_fill_brewer(palette = "Paired") +
        theme_minimal() +
        theme(axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1), legend.position = "none") +
        labs(title = paste("Expression of", gene, "in", cluster),
             x = "Sample Group",
             y = "Expression Level")
    
    print(p)
    
    pdf_filename <- paste0(cluster_dir, "/Expression_", gene, "_", cluster, "_violin_plot.pdf")
    ggsave(filename = pdf_filename, plot = p, width = 14, height = 8)
    plot_list[[gene]] <- p
  }
  
  combined_plot <- wrap_plots(plot_list, ncol = 3)
  ggsave(filename = paste0(cluster_dir, "/combined_Violin_Plot.pdf"), 
       plot = combined_plot, width = 24, height = 15)
}
```

### ??Task 5.1.5 Plots for NES scores

```{r}
cluster1_data <- subset(seurat_object_b, idents = "Cluster_1")
cluster2_data <- subset(seurat_object_b, idents = "Cluster_2")

```





```{r}
## Gene Set Variation Analysis (GSVA) or Single Sample GSEA (ssGSEA)

library(GSVA)
library(limma)

# Assuming you have a matrix of expression data
expr_matrix <- GetAssayData(seurat_object_b, assay = "RNA", layer = "data")

# Convert Seurat clusters to a binary matrix format suitable for GSVA
cluster1_matrix <- expr_matrix[, WhichCells(seurat_object_b, idents = "Cluster_1")]
cluster2_matrix <- expr_matrix[, WhichCells(seurat_object_b, idents = "Cluster_2")]

msigdbr.Hallmark.df = msigdbr(species = "Homo sapiens", category = "H")
# Define gene sets, converting from the format used in fgsea
gene_sets <- msigdbr.Hallmark.df %>%
  split(.$gene_symbol)

# Running GSVA
gsva_results_cluster1 <- gsva(cluster1_matrix, gene_sets, method = "gsva")
gsva_results_cluster2 <- gsva(cluster2_matrix, gene_sets, method = "gsva")

# Look at the results for "Fatty Acid Metabolism"
fatty_acid_score_cluster1 <- gsva_results_cluster1["HALLMARK_FATTY_ACID_METABOLISM",]
fatty_acid_score_cluster2 <- gsva_results_cluster2["HALLMARK_FATTY_ACID_METABOLISM",]

# Output the results
print(fatty_acid_score_cluster1)
print(fatty_acid_score_cluster2)

```

## Task 5.2 Bar plot - proportion of each cluster in each sample

```{r}
bar_plot_data <- as.data.frame(seurat_object_b@meta.data)
bar_plot_data$cluster <- Idents(seurat_object_b)  # Add cluster identities as a column

# Calculate proportions of each cluster within each sample
proportion_data <- bar_plot_data %>%
  group_by(new_labels) %>%
  dplyr::count(cluster) %>%
  mutate(proportion = n / sum(n)) %>%
  ungroup() %>% 
  # Set the factor levels to control plot order
  mutate(new_labels = factor(new_labels, levels = sample_order))
```

```{r}
# Plot for Cluster proportions
cluster_proportions_plot <- ggplot(proportion_data, aes(x = new_labels, y = proportion, fill = cluster)) +
  geom_bar(stat = "identity", position = "stack") +
  geom_text(aes(label = scales::percent(proportion, accuracy = 0.01)), position = position_fill(vjust = 0.5), size = 2, color = "white") +
  labs(x = "Samples", y = "Proportion of Clusters", title = "Proportion of B-ALL Clusters in Each Sample") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

print(cluster_proportions_plot)

filename <- "Task5.2_Proportion_of_B-ALL_Clusters_in_Each_Sample.pdf"
path <- paste0(Task5_B_ALL_Cell_Plots)
ggsave(filename = file.path(path, filename), plot = cluster_proportions_plot, width = 10, height = 8)
```

## Task 5.3 UMAP Comparison

```{r}
Task5.3_UMAP_Comparison <- paste0(Task5_B_ALL_Cell_Plots, "/Task5.3_UMAP_Comparison")
  
if(!exists(Task5.3_UMAP_Comparison)){
  dir.create(Task5.3_UMAP_Comparison)
}
```

### Task 5.3.1 48h vs. 72h

```{r}
Task5.3.1_48h_vs_72h <- paste0(Task5.3_UMAP_Comparison, "/Task5.3.1_48h_vs_72h")
  
if(!exists(Task5.3.1_48h_vs_72h)){
  dir.create(Task5.3.1_48h_vs_72h)
}
```

```{r}
# Goal: Generate UMAP plot for all samples (every timepoint) of each sample
# a.WT WT Mock and CAR (black/grey)
# b.WT KO Mock and CAR (blues)
# c.KO WT Mock and CAR (reds)
# d.KO KO Mock and CAR (greens)
```

```{r}
table(seurat_object_b@meta.data$new_labels)
```

```{r}
# Test:

ko_ko_car <- subset(seurat_object_b, subset = new_labels %in% c("KO_KO_CAR_48", "KO_KO_CAR_72"))

set.seed(123)
# p <- DimPlot(ko_ko_car, reduction = "umap", group.by =  "new_labels", label = TRUE, repel = TRUE, label.size = 3) 
# p <- p + theme(legend.text = element_text(size = 6))
# p

# Plot UMAP
p <- UMAPPlot(ko_ko_car, label = FALSE, group.by = "new_labels", pt.size = 0.2) +
  ggtitle("UMAP for KO_KO_CAR: 48 vs 72 hours") +
  theme_minimal()
p
```

```{r}
# Define the groups of interest
groups <- c("KO_KO_CAR", "KO_KO_Mock", "KO_WT_CAR", "KO_WT_Mock", "WT_KO_CAR", "WT_KO_Mock", "WT_WT_CAR", "WT_WT_Mock")

# Initialize a list to store plots
plot_list <- list()

# Loop through each group
for (group in groups) {
  # Extract the specific time points for each group
  time_points <- grep(group, names(table(seurat_object_b@meta.data$new_labels)), value = TRUE)
  
  # Subset the Seurat object for these time points
  subset_seurat <- subset(seurat_object_b, subset = new_labels %in% time_points)
  
  # Plot UMAP
  p <- UMAPPlot(subset_seurat, label = FALSE, group.by = "new_labels", pt.size = 0.2) +
    ggtitle(paste("UMAP for", group, ": 48 vs 72 hours")) +
    theme_minimal()
  
  # plot <- UMAPPlot(subset_seurat, group.by = "new_labels", pt.size = 0.2) +
  #   ggtitle(paste(group)) +
  #   theme_minimal() +
  #   theme(legend.position = c(0.7, 0.7),  # Adjust these coordinates to move the legend inside the plot
  #         legend.justification = c("left", "bottom")) # Adjusts the anchor point of the legend
  # # Store the plot in the list
  # plot_list[[group]] <- plot
  
   # Store the plot in the list with a unique key
    key <- paste(group)
    plot_list[[key]] <- p
  
  ggsave(paste0(Task5.3.1_48h_vs_72h, "/", group, "_UMAP.pdf"), plot = p, width = 10, height = 8)
}

combined_plot <- wrap_plots(plot_list, ncol = 3) 
ggsave(paste0(Task5.3.1_48h_vs_72h, "/All_UMAP_48h_vs_72h.pdf"), plot = combined_plot, width = 20, height = 15)
```

### Task 5.3.2 Mock vs. CAR

```{r}
Task5.3.2_Mock_vs_CAR <- paste0(Task5.3_UMAP_Comparison, "/Task5.3.2_Mock_vs_CAR")
  
if(!exists(Task5.3.2_Mock_vs_CAR)){
  dir.create(Task5.3.2_Mock_vs_CAR)
}
```

```{r}
# Define the main conditions and time points
conditions <- c("KO_KO", "KO_WT", "WT_KO", "WT_WT")
time_points <- c("48", "72")

# Initialize a list to store plots
plot_list <- list()

# Loop through each condition and time point
for (condition in conditions) {
  for (time in time_points) {
    # Define the groups for CAR and Mock within each condition at a specific time
    group_Mock <- paste(condition, "Mock", time, sep = "_")
    group_CAR <- paste(condition, "CAR", time, sep = "_")

    # Subset the Seurat object for CAR and Mock groups at the current time
    subset_seurat <- subset(seurat_object_b, subset = new_labels %in% c(group_Mock, group_CAR))
    
    # Plot UMAP comparing CAR vs Mock at this time point
    plot_title <- paste(condition, "Mock vs CAR at", time, "hours")
    p <- UMAPPlot(subset_seurat, label = FALSE, group.by = "new_labels", pt.size = 0.2) +
      ggtitle(plot_title) +
      theme_minimal()

    # Store the plot in the list with a unique key
    key <- paste(condition, time, sep = "_")
    plot_list[[key]] <- p
    
    # Optionally save the plot to a PDF
    ggsave(paste0(Task5.3.2_Mock_vs_CAR, "/", condition, "_", time, "_UMAP.pdf"), plot = p, width = 10, height = 8)
  }
}

# Combine all plots into one PDF file
combined_plot <- wrap_plots(plot_list, ncol = 3) 
ggsave(paste0(Task5.3.2_Mock_vs_CAR, "/All_UMAP_Mock_vs_CAR.pdf"), plot = combined_plot, width = 20, height = 15)
```


### ** Task 5.3.3 Contour

```{r}
seurat_object_b@reductions$umap
```

```{r}
# Extract UMAP coordinates
umap_data <- as.data.frame(Embeddings(seurat_object_b, "umap"))
umap_data$sampleID <- seurat_object_b@meta.data$sampleID

ggplot(umap_data, aes(x = UMAP_1, y = UMAP_2, colour = sampleID)) +
  # geom_point(size = 0.1, alpha = 0.2) + # scatter plot points
  stat_density_2d(color = "gray16", size = 0.3) + # contours
  facet_wrap(~sampleID) +
  theme_minimal(base_size = 15) +
  ylab("UMAP_2") +
  xlab("UMAP_1") +
  theme(legend.position = "none")

ggcells(seurat_object_b, mapping=aes(x=umap_data$umap_1,
                           y=umap_data$umap_2,
                           colour=sampleID)) +
 geom_point(size = 0.1, alpha = 0.2) + # this generates the scatter plot
 stat_density_2d(color= "gray16", size = 0.3) + # this generates the contours
 facet_wrap(~sampleID) +
 theme_minimal(base_size = 15) +
 ylab("UMAP_2") + xlab("UMAP_1") +
 theme(legend.position = "none")
```

```{r}
# Convert Seurat object to SingleCellExperiment
sce_object <- as.SingleCellExperiment(seurat_object_b)

# Use ggcells to create the plot
ggcells(sce_object, aes(x = UMAP_1, y = UMAP_2, colour = sampleID)) +
  geom_point(size = 0.1, alpha = 0.2) + # scatter plot points
  stat_density_2d(color = "gray16", size = 0.3) + # contours
  facet_wrap(~sampleID) +
  theme_minimal(base_size = 15) +
  ylab("UMAP_2") +
  xlab("UMAP_1") +
  theme(legend.position = "none")
```

```{r}
example_sce <- mockSCE()
example_sce <- logNormCounts(example_sce)
example_sce <- runPCA(example_sce)

ggcells(example_sce, aes(x=PCA.1, y=PCA.2, colour=Gene_0001)) +
    geom_point()

ggcells(example_sce, aes(x=Mutation_Status, y=Gene_0001)) +
    geom_violin() +
    facet_wrap(~Cell_Cycle)

rowData(example_sce)$GC <- runif(nrow(example_sce))
ggfeatures(example_sce, aes(x=GC, y=Cell_001)) +
    geom_point() +
    stat_smooth()
```

## Task 5.4 Analysis for each comparison (Mock vs. CAR)

```{r}
Task5.4_Mock_vs_CAR <- paste0(Task5_B_ALL_Cell_Plots, "/Task5.4_Mock_vs_CAR")
  
if(!exists(Task5.4_Mock_vs_CAR)){
  dir.create(Task5.4_Mock_vs_CAR)
}
```

### Task 5.4.1 DE gene analysis

```{r}
Task5.4.1_DE_genes <- paste0(Task5.4_Mock_vs_CAR, "/Task5.4.1_DE_genes")
  
if(!exists(Task5.4.1_DE_genes)){
  dir.create(Task5.4.1_DE_genes)
}
```

```{r}
# Test: a.Cluster 1: WT_WT_48 Mock versus CAR

table(Idents(seurat_object_b))
table(seurat_object_b@meta.data$new_labels)

# subset_seurat <- subset(seurat_object_b, subset = new_labels %in% c("WT_WT_CAR_48", "WT_WT_Mock_48") & Idents(seurat_object_b) == "Cluster_1")
# 
# # Set identities to be specifically the conditions for DE analysis
# Idents(subset_seurat) <- subset_seurat$new_labels
# 
# de_results <- FindMarkers(subset_seurat, ident.1 = "WT_WT_Mock_48", ident.2 = "WT_WT_CAR_48", min.pct = 0.1, logfc.threshold = 0.25)
# 
# head(de_results)
```

```{r}
# For loop for all combinations:

# Initialize containers for results
de_results_list <- list()
de_results_tibble <- tibble()

conditions <- c("WT_WT", "WT_KO", "KO_WT", "KO_KO")
time_points <- c("48", "72")
clusters <- c("Cluster_1", "Cluster_2")

for (condition in conditions) {
  for (time in time_points) {
    for (cluster in clusters) {
      # Define new labels for CAR and Mock
      car_label <- paste(condition, "CAR", time, sep = "_")
      mock_label <- paste(condition, "Mock", time, sep = "_")
      
      # Subset Seurat object for the current combination
      subset_seurat <- subset(seurat_object_b, subset = new_labels %in% c(car_label, mock_label) & Idents(seurat_object_b) == cluster)
      
      # Set identities to be specifically the conditions for DE analysis
      Idents(subset_seurat) <- subset_seurat$new_labels
      
      # Check if there are enough cells to perform DE analysis
      if (length(table(Idents(subset_seurat))) < 2) {
        cat("Not enough data to perform DE analysis for", car_label, "vs", mock_label, "in", cluster, "\n")
        next
      }
      
      # Perform DE analysis
      de_results <- FindMarkers(subset_seurat, ident.1 = mock_label, ident.2 = car_label, min.pct = 0.1, logfc.threshold = 0.25)
      # Save results to list
      de_results_list[[paste(condition, time, cluster, "Mock_vs_CAR", sep = "_")]] <- de_results

      # Directory for saving the results
      result_dir <- paste0(Task5.4.1_DE_genes, "/", condition)
      if (!dir.exists(result_dir)) {
        dir.create(result_dir, recursive = TRUE)
      }
      
      # Save DE results to CSV
      write.csv(de_results, paste0(result_dir, "/", condition, "_", time, "_", cluster, "_Mock_vs_CAR.csv"))
    }
  }
}
```

```{r}
de_results_list
```

```{r}
# Convert the list of DE results into a tibble
de_results_tibble <- tibble(
  Comparison = names(de_results_list),
  Results = de_results_list
)
```

### Task 5.4.2 GSEA Hallmarks

```{r}
Task5.4.2_GSEA_Hallmark_results <- paste0(Task5.4_Mock_vs_CAR, "/Task5.4.2_GSEA_Hallmark_results")
  
if(!exists(Task5.4.2_GSEA_Hallmark_results)){
  dir.create(Task5.4.2_GSEA_Hallmark_results)
}
```

```{r}
# Test for one comparison:
msigdbr.Hallmark.df = msigdbr(species = "Homo sapiens", category = "H")
fgsea_hallmark_sets = msigdbr.Hallmark.df %>% 
  # mutate(gs_name = str_remove(gs_name, "HALLMARK_")) %>% 
  split(x = .$gene_symbol, f = .$gs_name)

markers_to_rank <- de_results_tibble$Results[[2]]
markers_to_rank$gene_symbol <- rownames(markers_to_rank)

markers_to_rank |>
  dplyr::select(gene_symbol, avg_log2FC) |>
  arrange(desc(avg_log2FC)) |>
  deframe() -> ranks

fgseaRes = fgsea(fgsea_hallmark_sets, stats = ranks)

fgseaResTidy = fgseaRes %>%
    mutate(abbrev_pathway = abbreviate(pathway)) |> 
    relocate(abbrev_pathway, .after = pathway) |> 
    as_tibble() %>%
    arrange(desc(NES))

  # only plot the top 40 pathways
  fgseaResTidy %>%
    mutate(NES2 = ifelse(NES>0, "Enriched in Mock", "Enriched in CAR")) %>%
    # mutate(pathway = abbreviate(pathway)) |> 
    # dplyr::filter(padj < 0.05) %>%
    dplyr::filter(pval < 0.05) %>%
    arrange(desc(NES)) %>%
    head(n = 40) -> GSEA.plot.data
  
  # Output plot data to CSV
  GSEA.plot.data %>% 
    mutate(Lead_size = as.integer(map(leadingEdge, length))) %>% 
    mutate(Lead_Genes = as.character(map(leadingEdge, paste0, collapse = ","))) %>%
    dplyr::select(-c(leadingEdge, NES2, size))
  
  # Column Plot
  cols = c("Enriched in Mock" = "green", "Enriched in CAR" = "red")
  
  GSEA.plot.data %>% 
    ggplot(aes(fct_reorder(pathway, NES), NES)) +
      geom_col(aes(fill= NES2)) +
      # scale_fill_manual("NES", values = cols) +
      scale_fill_manual("NES", values = cols, breaks = c("Enriched in Mock", "Enriched in CAR")) +
      coord_flip() + 
      theme(axis.text.y = element_text(size = 6)) +
      labs(x="Pathway", y="Normalized Enrichment Score",
           title=paste0("B-ALL_Cluster1_versus_Cluster2")) 
```

```{r}
GSEA_sample_dir_significant <- paste0(Task5.4.2_GSEA_Hallmark_results, "/most_significant_pathways")

if(!dir.exists(paste0(GSEA_sample_dir_significant, "/res_data"))) {
  dir.create(paste0(GSEA_sample_dir_significant, "/res_data"), recursive = TRUE)
}

if(!dir.exists(paste0(GSEA_sample_dir_significant, "/plot_data"))) {
  dir.create(paste0(GSEA_sample_dir_significant, "/plot_data"), recursive = TRUE)
}

if(!dir.exists(paste0(GSEA_sample_dir_significant, "/Plots"))) {
  dir.create(paste0(GSEA_sample_dir_significant, "/Plots"), recursive = TRUE)
}
```

```{r}
# Prepare Hallmark gene sets for fgsea
prepareGeneSets <- function() {
  msigdbr.Hallmark.df <- msigdbr(species = "Homo sapiens", category = "H")
  fgsea_hallmark_sets <- msigdbr.Hallmark.df %>% 
    split(x = .$gene_symbol, f = .$gs_name)
  return(fgsea_hallmark_sets)
}

# Perform fgsea and handle results
run_fgsea_save_results <- function(de_results, comparison_name, output_dir) {
  # Generate ranks for fgsea
  markers_to_rank <- as.data.frame(de_results)
  markers_to_rank$gene_symbol <- rownames(markers_to_rank)
  
  ranks <- markers_to_rank %>%
    dplyr::select(gene_symbol, avg_log2FC) %>%
    arrange(desc(avg_log2FC)) %>%
    deframe()

  # Run fgsea
  fgseaRes <- fgsea(prepareGeneSets(), stats = ranks)
  
  # Process and save results
  fgseaResTidy <- fgseaRes %>%
    mutate(abbrev_pathway = abbreviate(pathway)) |> 
    relocate(abbrev_pathway, .after = pathway) |> 
    as_tibble() %>%
    arrange(desc(NES))
  
  write_csv(fgseaResTidy, file = paste0(output_dir, "/res_data/GSEA_HALLMARK_B-ALL_", comparison_name, ".csv"))
  
  # Output plots
  output_plotData(fgseaResTidy, comparison_name, output_dir)
}

# Output plots and summary tables
output_plotData <- function(fgseaResTidy, comparison_name, output_dir) {
  # only plot the top 40 pathways
  fgseaResTidy %>%
    mutate(NES2 = ifelse(NES > 0, "Enriched in Mock", "Enriched in CAR")) %>%
    filter(pval < 0.05) %>%
    arrange(desc(NES)) %>%
    head(n = 40) -> GSEA.plot.data

  GSEA.plot.data %>%
    mutate(Lead_size = as.integer(map(leadingEdge, length))) %>%
    mutate(Lead_Genes = as.character(map(leadingEdge, paste0, collapse = ","))) %>%
    dplyr::select(-c(leadingEdge, NES2, size)) %>% 
    write_csv(file = paste0(output_dir, "/plot_data/GSEA_HALLMARK_Plot_data_", comparison_name, ".csv"))

  # Column Plot
  cols = c("Enriched in Mock" = "green", "Enriched in CAR" = "red")
  
  p <- GSEA.plot.data %>%
      ggplot(aes(fct_reorder(pathway, NES), NES)) +
      geom_col(aes(fill = NES2)) +
      # scale_fill_manual("NES", values = cols) +
      scale_fill_manual("NES", values = cols, breaks = c("Enriched in Mock", "Enriched in CAR")) +
      coord_flip() + 
      theme(axis.text.y = element_text(size = 6)) +
      labs(x = "Pathway", y = "Normalized Enrichment Score", title = comparison_name)
  ggsave(filename = paste0(output_dir, "/Plots/GSEA_HALLMARK_B-ALL_", comparison_name, ".pdf"))
    
  return(p)
}

# Loop through each comparison
results <- de_results_tibble

# Store plot objects in a list
plot_list <- list()

for (i in seq_len(nrow(results))) {
  comparison_name <- results$Comparison[i]
  de_results_sample <- results$Results[[i]]
  output_dir <- GSEA_sample_dir_significant
  
  # run_fgsea_save_results(de_results_sample, comparison_name, output_dir)
  plot_list[[comparison_name]] <- run_fgsea_save_results(de_results_sample, comparison_name, output_dir)
}

# Assuming 4x4 grid for 16 plots
combined_plot <- wrap_plots(plot_list, ncol = 4)
ggsave(filename = paste0(GSEA_sample_dir_significant, "/combined_GSEA_plots.pdf"), 
       plot = combined_plot, width = 30, height = 20)
```

```{r}
GSEA_sample_dir_pos_neg <- paste0(Task5.4.2_GSEA_Hallmark_results, "/pos_and_neg_top_pathways")

if(!dir.exists(paste0(GSEA_sample_dir_pos_neg, "/res_data"))) {
  dir.create(paste0(GSEA_sample_dir_pos_neg, "/res_data"), recursive = TRUE)
}

if(!dir.exists(paste0(GSEA_sample_dir_pos_neg, "/plot_data"))) {
  dir.create(paste0(GSEA_sample_dir_pos_neg, "/plot_data"), recursive = TRUE)
}

if(!dir.exists(paste0(GSEA_sample_dir_pos_neg, "/Plots"))) {
  dir.create(paste0(GSEA_sample_dir_pos_neg, "/Plots"), recursive = TRUE)
}
```

```{r}
# Select the top pathways that are enriched in Mock and CAR, respectively:

# Prepare Hallmark gene sets for fgsea
prepareGeneSets <- function() {
  msigdbr.Hallmark.df <- msigdbr(species = "Homo sapiens", category = "H")
  fgsea_hallmark_sets <- msigdbr.Hallmark.df %>% 
    split(x = .$gene_symbol, f = .$gs_name)
  return(fgsea_hallmark_sets)
}

# Perform fgsea and handle results
run_fgsea_save_results <- function(de_results, comparison_name, output_dir) {
  # Generate ranks for fgsea
  markers_to_rank <- as.data.frame(de_results)
  markers_to_rank$gene_symbol <- rownames(markers_to_rank)
  
  ranks <- markers_to_rank %>%
    dplyr::select(gene_symbol, avg_log2FC) %>%
    arrange(desc(avg_log2FC)) %>%
    deframe()

  # Run fgsea
  fgseaRes <- fgsea(prepareGeneSets(), stats = ranks)
  
  # Process and save results
  fgseaResTidy <- fgseaRes %>%
    mutate(abbrev_pathway = abbreviate(pathway)) |> 
    relocate(abbrev_pathway, .after = pathway) |> 
    as_tibble() %>%
    arrange(desc(NES))
  
  write_csv(fgseaResTidy, file = paste0(output_dir, "/res_data/GSEA_HALLMARK_B-ALL_", comparison_name, ".csv"))
  
  # Output plots
  output_plotData(fgseaResTidy, comparison_name, output_dir)
}

# Output plots and summary tables
output_plotData <- function(fgseaResTidy, comparison_name, output_dir) {
  # only plot the top 40 pathways
  fgseaResTidy %>%
    mutate(NES2 = ifelse(NES > 0, "Enriched in Mock", "Enriched in CAR")) %>%
    group_by(NES2) %>%
    arrange(pval) %>%
    slice_head(n = 10) %>%
    ungroup() %>%
    bind_rows() %>%
    arrange(desc(NES)) -> GSEA.plot.data.pos_and_neg
  
  GSEA.plot.data.pos_and_neg %>%
    mutate(Lead_size = as.integer(map(leadingEdge, length))) %>%
    mutate(Lead_Genes = as.character(map(leadingEdge, paste0, collapse = ","))) %>%
    dplyr::select(-c(leadingEdge, NES2, size)) %>% 
    write_csv(file = paste0(output_dir, "/plot_data/GSEA_HALLMARK_Plot_data_", comparison_name, ".csv"))

  # Column Plot
  cols = c("Enriched in Mock" = "green", "Enriched in CAR" = "red")
  
  p <- GSEA.plot.data.pos_and_neg %>%
    ggplot(aes(fct_reorder(pathway, NES), NES)) +
    geom_col(aes(fill = NES2)) +
    # scale_fill_manual("NES", values = cols) +
    scale_fill_manual("NES", values = cols, breaks = c("Enriched in Mock", "Enriched in CAR")) +
    coord_flip() + 
    theme(axis.text.y = element_text(size = 6)) +
    labs(x = "Pathway", y = "Normalized Enrichment Score", title = comparison_name)
  ggsave(filename = paste0(output_dir, "/Plots/GSEA_HALLMARK_B-ALL_", comparison_name, ".pdf"))
  
  return(p)
}

# Loop through each comparison
results <- de_results_tibble

plot_list <- list()

for (i in seq_len(nrow(results))) {
  comparison_name <- results$Comparison[i]
  de_results_sample <- results$Results[[i]]
  output_dir <- GSEA_sample_dir_pos_neg
  
  plot_list[[comparison_name]] <- run_fgsea_save_results(de_results_sample, comparison_name, output_dir)
}

# Assuming 4x4 grid for 16 plots
combined_plot <- wrap_plots(plot_list, ncol = 4)
ggsave(filename = paste0(GSEA_sample_dir_pos_neg, "/combined_GSEA_plots.pdf"), 
       plot = combined_plot, width = 30, height = 20)
```

# SAVE POINT

```{r}
# saveRDS(de_results_tibble, file = paste0(save_point, "/de_results_tibble.rds"))

# de_results_tibble <- readRDS(paste0(save_point, "/de_results_tibble.rds"))
```

### Task 5.4.3 GSEA C2 CP KEGG_LEGACY

```{r}
Task5.4.3_GSEA_KEGG_MAPK_SIGNALING_PATHWAY <- paste0(Task5.4_Mock_vs_CAR, "/Task5.4.3_GSEA_KEGG_MAPK_SIGNALING_PATHWAY")
  
if(!exists(Task5.4.3_GSEA_KEGG_MAPK_SIGNALING_PATHWAY)){
  dir.create(Task5.4.3_GSEA_KEGG_MAPK_SIGNALING_PATHWAY)
}
```

```{r}
#### C2 CP:KEGG_LEGACY

msigdbr.C2.CP.KL.df = msigdbr(species = "Homo sapiens", category = "C2", subcategory = "CP:KEGG")
# msigdbr.C2.CP.KL.df
```

```{r}
msigdbr.C2.CP.KL.df_set = msigdbr.C2.CP.KL.df %>% 
  split(x = .$gene_symbol, f = .$gs_name)
```

```{r}
pathway <- "KEGG_MAPK_SIGNALING_PATHWAY"

plot_list <- list()

# Iterate over each comparison in the de_results_tibble
for(i in seq_along(de_results_tibble$Comparison)) {
  comparison_name <- de_results_tibble$Comparison[i]
  markers_to_rank <- de_results_tibble$Results[[i]]
  
  # Prepare the ranks
  markers_to_rank$gene_symbol <- rownames(markers_to_rank)
  ranks <- markers_to_rank %>%
    dplyr::select(gene_symbol, avg_log2FC) %>%
    arrange(desc(avg_log2FC)) %>%
    deframe()
  
  # Run fgsea
  fgseaRes <- fgsea(msigdbr.C2.CP.KL.df_set, stats = ranks)
  
  # Plot enrichment
  plot <- plotEnrichment(msigdbr.C2.CP.KL.df_set[[pathway]], ranks) +
    labs(title = paste(pathway, ":", comparison_name)) +
    annotate("text", x = -Inf, y = -Inf, hjust = 0, vjust = -0.3, label = "Enriched in Mock") +
    annotate("text", x = Inf, y = -Inf, hjust = 1, vjust = -0.3, label = "Enriched in CAR")
  
  ggsave(filename = paste0(Task5.4.3_GSEA_KEGG_MAPK_SIGNALING_PATHWAY, "/plotEnrichment_", comparison_name, ".pdf"), plot = plot, width = 8, height = 6, units = "in")
  
  plot_list[[comparison_name]] <- plot
}

# Assuming 4x4 grid for 16 plots
combined_plot <- wrap_plots(plot_list, ncol = 4)
ggsave(filename = paste0(Task5.4.3_GSEA_KEGG_MAPK_SIGNALING_PATHWAY, "/combined_Enrichment_plots.pdf"),
       plot = combined_plot, width = 30, height = 20)
```

## Task 5.5 Henry_SuperStructure Data Z-Score

```{r}
seurat_object_b <- readRDS(paste0(save_point, "/B-ALL_clusters_final_rerun_Cluster1and2.rds"))
seurat_object_b@meta.data
```

```{r}
bulk <- AggregateExpression(seurat_object_b, group.by = "new_labels", return.seurat = TRUE)
# bulk <- AggregateExpression(seurat_object_b, group.by = "new_labels", return.seurat = FALSE)

Cells(bulk)
bulk@assays
bulk@meta.data

# saveRDS(bulk, file = paste0(save_point, "/seurat_object_b_bulk.rds"))
bulk <- readRDS(paste0(save_point, "/seurat_object_b_bulk.rds"))
```

```{r}
Henry_file_path <- "Gene List for MW_09_14_2024.xlsx"

Henry_data <- read_excel(Henry_file_path, sheet = 1, col_names = FALSE)

# Extract the second column as a gene list
Henry_gene_list <- Henry_data[[2]]

Henry_gene_list
```

```{r}
# Function to clean and split gene names
clean_and_split_genes <- function(genes) {
  # Replace " or " with "/" to have a single delimiter
  cleaned_genes <- str_replace_all(genes, " or ", "/")
  
  # Split the gene names by "/" (to handle both "or" and "/")
  split_genes <- str_split(cleaned_genes, "/")
  
  # Flatten the list into a single vector
  split_genes <- unlist(split_genes)
  
  # Trim any leading/trailing whitespace
  split_genes <- str_trim(split_genes)
  
  # Replace "IL-15" with "IL15"
  split_genes <- str_replace_all(split_genes, "IL-15", "IL15")
  
  return(split_genes)
}

Henry_final_gene_list <- unlist(lapply(Henry_gene_list, clean_and_split_genes))

Henry_final_gene_list
```

```{r}
bulk_data <- GetAssayData(bulk, assay = "RNA", layer = "data")

# Z-score plotting function, using Henry_gene_list
plot_henry_expression <- function(genes, pathway_name = "Henry_SuperStructure Gene List") {
  # Filter bulk_data for the current pathway's genes
  pathway_data <- bulk_data[rownames(bulk_data) %in% genes, ]
  # Calculate z-scores
  z_scores <- t(scale(t(pathway_data)))
  # Remove the NaN rows
  z_scores <- z_scores[complete.cases(z_scores), ]

  # Calculate the mean z-score for each sample
  mean_z_scores <- colMeans(z_scores)
  
  # Convert mean_z_scores to a data frame for ggplot
  mean_z_scores_df <- data.frame(Sample = names(mean_z_scores), MeanZScore = mean_z_scores)
  
  # Extract patient identifiers assuming the format "PatientID-X"
  mean_z_scores_df$Group <- gsub("-(48|72)$", "", mean_z_scores_df$Sample)
  # Assign colors to each patient group
  mean_z_scores_df$Color <- as.factor(mean_z_scores_df$Group)
  
  # Generate colors for plotting
  number_of_groups <- length(unique(mean_z_scores_df$Color))
  colors <- colorRampPalette(brewer.pal(min(12, number_of_groups), "Set3"))(number_of_groups)
  
  # Create and return a ggplot object
  p <- ggplot(mean_z_scores_df, aes(x = Sample, y = MeanZScore, fill = Color)) +
    geom_bar(stat = "identity") +
    geom_text(aes(label = sprintf("%.2f", MeanZScore), vjust = ifelse(MeanZScore >= 0, -0.3, 1.3)), color = "black", size = 2) +
    scale_fill_manual(values = colors) +
    theme_minimal() +
    labs(title = paste("Mean Z-Scores for", pathway_name),
         x = "Sample",
         y = "Mean Z-Score") +
    theme(axis.text.x = element_text(angle = 45, hjust = 1),
          legend.position = "none")
  
  print(p)
  
  # Save the plot
  filename <- paste("Task5.5_Mean Z-Scores for", pathway_name, ".pdf")
  path <- paste0(Task5_B_ALL_Cell_Plots)
  ggsave(filename = file.path(path, filename), plot = p, width = 10, height = 8)
  
  # Create a heatmap using SeuratExtend::Heatmap
  heatmap_plot <- SeuratExtend::Heatmap(
    z_scores,  # Matrix with gene expression z-scores
    main = paste("Z-Score Heatmap for", pathway_name),
    color = colorRampPalette(c("blue", "white", "red"))(100),
    lab_fill = "Z-Score",
    # Adjust the left margin to ensure long labels are not cut off
    plot.margin = margin(t = 5.5, r = 5.5, b = 5.5, l = 30) 
  )
  
  # Save the heatmap
  heatmap_filename <- paste("Task5.5_Heatmap Z-Scores for", pathway_name, ".pdf")
  ggsave(filename = file.path(path, heatmap_filename), plot = heatmap_plot, width = 12, height = 10)

}

plot_henry_expression(Henry_final_gene_list)
```

```{r}
# Check Which genes are not in bulk_genes

bulk_genes <- rownames(bulk_data)

genes_in_bulk <- Henry_final_gene_list[Henry_final_gene_list %in% bulk_genes]

genes_not_in_bulk <- Henry_final_gene_list[!(Henry_final_gene_list %in% bulk_genes)]

# Output the results
cat("Genes found in bulk_data:\n")
print(genes_in_bulk)

cat("\nGenes NOT found in bulk_data:\n")
print(genes_not_in_bulk)

if ("IL15" %in% bulk_genes) {
  cat("IL15 is present in bulk_genes.\n")
} else {
  cat("IL15 is NOT present in bulk_genes.\n")
}
```





# 6. Combine with Pool7 and Pool8

```{r}
Task6_Combined_data_for_all_pools <- paste0(folder.name, "/Task6_Combined_data_for_all_pools")
  
if(!exists(Task6_Combined_data_for_all_pools)){
  dir.create(Task6_Combined_data_for_all_pools)
}
```

## Task 6.1 Using filter/subset method 

```{r}
### Merge all samples and then subset the manuallymodified clusters

# List of sample names
sample_names <- c(
  "Pool2_Mock_1_16_48h_B1",
  "Pool2_Mock_1_16_48h_B2",
  "Pool2_Mock_1_16_48h_B3",
  "Pool2_Mock_1_16_48h_B4",
  "Pool3_Mock_1_16_72h_C1",
  "Pool3_Mock_1_16_72h_C2",
  "Pool3_Mock_1_16_72h_C3",
  "Pool3_Mock_1_16_72h_C4",
  "Pool5_CAR_1_16_48h_E1",
  "Pool5_CAR_1_16_48h_E2",
  "Pool5_CAR_1_16_48h_E3",
  "Pool5_CAR_1_16_48h_E4",
  "Pool6_CAR_1_16_72h_F1",
  "Pool6_CAR_1_16_72h_F2",
  "Pool6_CAR_1_16_72h_F3",
  "Pool6_CAR_1_16_72h_F4",
  "Pool7_PDX1",
  "Pool7_PDX3",
  "Pool7_PDX4",
  "Pool7_PDX5",
  # "Pool8_PDX6",
  "Pool8_PDX8",
  "Pool8_PDX9",
  "Pool8_PDX10"
)

# Create Seurat objects for the first dataset separately
first_sample <- sample_names[1]
first_file_path <- paste0("cellranger_multi_results_scRNAseq_697_B-ALL_resequenced/", first_sample, "/sample_filtered_feature_bc_matrix.h5")
first_data <- Read10X_h5(filename = first_file_path)
first_seurat_obj <- CreateSeuratObject(counts = first_data$`Gene Expression`, project = first_sample)
first_seurat_obj[['CMO']] = CreateAssayObject(counts = first_data$`Multiplexing Capture`)

# Create Seurat objects for the rest of the datasets
other_samples <- sample_names[-1]
seurat_objects <- list(first_seurat_obj)

# Loop through each other dataset name
for (sample_name in other_samples) {
  # Construct the file path
  file_path <- paste0("cellranger_multi_results_scRNAseq_697_B-ALL_resequenced/", sample_name, "/sample_filtered_feature_bc_matrix.h5")
  
  # Read the data
  data <- Read10X_h5(filename = file_path)
  
  # Create a Seurat object
  seurat_obj <- CreateSeuratObject(counts = data$`Gene Expression`, project = sample_name)
  seurat_obj[['CMO']] = CreateAssayObject(counts = data$`Multiplexing Capture`)
  
  # Store the Seurat object in the list
  seurat_objects[[sample_name]] <- seurat_obj
}

# Merge the Seurat objects
B_ALL_CAR.Object.All_Pools<- merge(x = first_seurat_obj, y = seurat_objects[-1], add.cell.id = sample_names)
```

```{r}
B_ALL_CAR.Object.All_Pools@assays
```

```{r}
B_ALL_CAR.Object.All_Pools@meta.data
```

```{r}
## Add Metadata

### Compute Num of gene per UMI

B_ALL_CAR.Object.All_Pools$log10GenePerUMI = log10(B_ALL_CAR.Object.All_Pools$nFeature_RNA) / log10(B_ALL_CAR.Object.All_Pools$nCount_RNA)
```

```{r}
### Compute Percent mito ratio

B_ALL_CAR.Object.All_Pools$mitoPct = PercentageFeatureSet(B_ALL_CAR.Object.All_Pools, pattern = "^MT-")
B_ALL_CAR.Object.All_Pools$mitoRatio = B_ALL_CAR.Object.All_Pools@meta.data$mitoPct / 100
```

```{r}
B_ALL_CAR.Object.All_Pools@meta.data
```

```{r}
## Add New Label Name

# Define the mapping between old labels and new labels
mapping <- c(
  "Pool2_Mock_1_16_48h_B1" = "WT_WT_Mock_48",
  "Pool2_Mock_1_16_48h_B2" = "WT_KO_Mock_48",
  "Pool2_Mock_1_16_48h_B3" = "KO_WT_Mock_48",
  "Pool2_Mock_1_16_48h_B4" = "KO_KO_Mock_48",
  "Pool3_Mock_1_16_72h_C1" = "WT_WT_Mock_72",
  "Pool3_Mock_1_16_72h_C2" = "WT_KO_Mock_72",
  "Pool3_Mock_1_16_72h_C3" = "KO_WT_Mock_72",
  "Pool3_Mock_1_16_72h_C4" = "KO_KO_Mock_72",
  "Pool5_CAR_1_16_48h_E1" = "WT_WT_CAR_48",
  "Pool5_CAR_1_16_48h_E2" = "WT_KO_CAR_48",
  "Pool5_CAR_1_16_48h_E3" = "KO_WT_CAR_48",
  "Pool5_CAR_1_16_48h_E4" = "KO_KO_CAR_48",
  "Pool6_CAR_1_16_72h_F1" = "WT_WT_CAR_72",
  "Pool6_CAR_1_16_72h_F2" = "WT_KO_CAR_72",
  "Pool6_CAR_1_16_72h_F3" = "KO_WT_CAR_72",
  "Pool6_CAR_1_16_72h_F4" = "KO_KO_CAR_72",
  "Pool7_PDX1" = "Pool7_PDX1",
  "Pool7_PDX3" = "Pool7_PDX3",
  "Pool7_PDX4" = "Pool7_PDX4",
  "Pool7_PDX5" = "Pool7_PDX5",
  # "Pool8_PDX6" = "Pool8_PDX6,
  "Pool8_PDX8" = "Pool8_PDX8",
  "Pool8_PDX9" = "Pool8_PDX9",
  "Pool8_PDX10" = "Pool8_PDX10"
)

# Apply the mapping to create the new_labels column in B_ALL_CAR.Object.All_Pools@meta.data
B_ALL_CAR.Object.All_Pools@meta.data$new_labels <- mapping[B_ALL_CAR.Object.All_Pools@meta.data$orig.ident]

# Move new_labels column right after orig.ident
B_ALL_CAR.Object.All_Pools@meta.data <- B_ALL_CAR.Object.All_Pools@meta.data[, c(1, ncol(B_ALL_CAR.Object.All_Pools@meta.data), 2:(ncol(B_ALL_CAR.Object.All_Pools@meta.data)-1))]

B_ALL_CAR.Object.All_Pools@meta.data
```

```{r}
seurat_b_t <- readRDS(paste0(save_point, "/B_ALL_CAR.Object_with_celltype_only_48h_72h_V5.rds"))
seurat_b_t_filtered <- readRDS(paste0(save_point, "/B_ALL_CAR.Object_with_celltype_only_48h_72h_filtered_final_SeuratV5.rds"))

# Get cell identifiers from original and filtered datasets
cells_in_seurat_b_t<- colnames(seurat_b_t)
cells_in_seuratb_t_filtered <- colnames(seurat_b_t_filtered)

# Identify cells that were removed
cells_removed <- setdiff(cells_in_seurat_b_t, cells_in_seuratb_t_filtered)

# Remove the identified cells from seurat3
B_ALL_CAR.Object.All_Pools_filtered <- subset(B_ALL_CAR.Object.All_Pools, cells = setdiff(colnames(B_ALL_CAR.Object.All_Pools), cells_removed))
```

```{r}
# Use standard normalization

DefaultAssay(B_ALL_CAR.Object.All_Pools_filtered) <- 'RNA'
B_ALL_CAR.Object.All_Pools_filtered <- NormalizeData(B_ALL_CAR.Object.All_Pools_filtered) %>% 
  FindVariableFeatures() %>% 
  ScaleData() %>% 
  RunPCA()
```

```{r}
# Determine percent of variation associated with each PC
pct <- B_ALL_CAR.Object.All_Pools_filtered[["pca"]]@stdev / sum(B_ALL_CAR.Object.All_Pools_filtered[["pca"]]@stdev) * 100
# pct

# Calculate cumulative percents for each PC
cumu <- cumsum(pct)
# cumu

# Determine which PC exhibits cumulative percent greater than 90% and % variation associated with the PC as less than 5
co1 <- which(cumu > 90 & pct < 5)[1]
co1
```

```{r}
# Identifies the PC where the percent change in variation between consecutive PCs is less than 0.1%
co2 <- sort(which((pct[1:length(pct) - 1] - pct[2:length(pct)]) > 0.1), decreasing = T)[1] + 1
co2
```

```{r}
# Choose the minimum of these two metrics as the PCs covering the majority of the variation in the data.
pcs <- min(co1, co2)
pcs
```

```{r}
# Default resolution: 0.8
B_ALL_CAR.Object.All_Pools_filtered <- B_ALL_CAR.Object.All_Pools_filtered %>%
  FindNeighbors(., dims = 1:pcs) %>%
  # Enable method = "igraph" to avoid casting large data to a dense matrix.
  FindClusters(., method = "igraph") %>%
  RunUMAP(.,
          dims = 1:40,
          # dims = 1:pcs,
          reduction = "pca",
          n.components = 3L)
``` 

```{r}
sample_colors <- c( 
  "#000075","#004DFF","dodgerblue2","steelblue4","#00B7FF",
  "#E31A1C","maroon","deeppink1","#FF00FF","orchid1",
  "green4","green1","#00FFFF","#BBFF00","#0FCFC0",
  "#8200FF","#911eb4",
  "#FF7F00","gold1","#FFFF00",
  "gray70","#F0B98D", "darkorange4"
)

sample_labels <- levels(as.factor(B_ALL_CAR.Object.All_Pools_filtered@meta.data$new_labels))
sample_colors <- setNames(sample_colors, sample_labels)

set.seed(123)

umap_plot <- dittoDimPlot(B_ALL_CAR.Object.All_Pools_filtered,
             var = "new_labels",
             color.panel = sample_colors,  # Use our custom colors
             size = 0.4,
             # legend.show = FALSE,
             legend.size = 5,
             do.label = TRUE,
             opacity = 0.5,
             labels.size = 1.5,
             reduction.use = "umap",
             xlab = "UMAP 1",
             ylab = "UMAP 2",
             main = "UMAP for All Samples"
             )

# Modify the plot to change legend text size
umap_plot <- umap_plot + theme(legend.position = "bottom",
                     legend.text = element_text(size = 8),
                     legend.spacing.x = unit(1, 'cm'), # Adjust spacing
                     legend.spacing.y = unit(1, 'cm')) 

ggsave(filename = paste0(Task6_Combined_data_for_all_pools, "/Task6.1_2D_UMAP_all_Pools_filtered.pdf"),
       plot = umap_plot,
       width = 12,
       height = 10)
```

# SAVE POINT

```{r}
# saveRDS(B_ALL_CAR.Object.All_Pools_filtered, file = paste0(save_point, "/B_ALL_CAR.Object.All_Pools_filtered.rds"))
```

```{r}
# B_ALL_CAR.Object.All_Pools_filtered <- readRDS(paste0(save_point, "/B_ALL_CAR.Object.All_Pools_filtered.rds"))
```

## Task 6.2 Exclude T cells

```{r}
plot <- DimPlot(object = B_ALL_CAR.Object.All_Pools_filtered)
cells.located = CellSelector(plot = plot)
```

```{r}
t_cell_cluster = B_ALL_CAR.Object.All_Pools_filtered[,cells.located]
```

```{r}
# Assuming cells.located contains the identifiers of the cells in t_cell_cluster
remaining_cells <- setdiff(colnames(B_ALL_CAR.Object.All_Pools_filtered), cells.located)

# Subset the main Seurat object to exclude these cells
B_ALL_CAR.Object.All_Pools_filtered_no_t <- subset(B_ALL_CAR.Object.All_Pools_filtered, cells = remaining_cells)
```

```{r}
# Use standard normalization

DefaultAssay(B_ALL_CAR.Object.All_Pools_filtered_no_t) <- 'RNA'
B_ALL_CAR.Object.All_Pools_filtered_no_t <- NormalizeData(B_ALL_CAR.Object.All_Pools_filtered_no_t) %>% 
  FindVariableFeatures() %>% 
  ScaleData() %>% 
  RunPCA()

# Determine percent of variation associated with each PC
pct <- B_ALL_CAR.Object.All_Pools_filtered_no_t[["pca"]]@stdev / sum(B_ALL_CAR.Object.All_Pools_filtered_no_t[["pca"]]@stdev) * 100
# pct

# Calculate cumulative percents for each PC
cumu <- cumsum(pct)
# cumu

# Determine which PC exhibits cumulative percent greater than 90% and % variation associated with the PC as less than 5
co1 <- which(cumu > 90 & pct < 5)[1]

# Identifies the PC where the percent change in variation between consecutive PCs is less than 0.1%
co2 <- sort(which((pct[1:length(pct) - 1] - pct[2:length(pct)]) > 0.1), decreasing = T)[1] + 1

pcs <- min(co1, co2)

# Default resolution: 0.8
B_ALL_CAR.Object.All_Pools_filtered_no_t.rerun <- B_ALL_CAR.Object.All_Pools_filtered_no_t %>%
  FindNeighbors(., dims = 1:pcs) %>%
  # Enable method = "igraph" to avoid casting large data to a dense matrix.
  FindClusters(., method = "igraph") %>%
  RunUMAP(.,
          dims = 1:40,
          # dims = 1:pcs,
          reduction = "pca",
          n.components = 3L)

set.seed(123)
p <- DimPlot(B_ALL_CAR.Object.All_Pools_filtered_no_t.rerun, reduction = "umap", group.by =  "new_labels", label = TRUE, repel = TRUE, label.size = 2) 
p <- p + theme(legend.text = element_text(size = 6))
p <- p + ggtitle("UMAP After Removing T-cells")
p
filename <- "Task6.2_UMAP_After_Removing_T-cells.pdf"
path <- paste0(Task6_Combined_data_for_all_pools)
ggsave(filename = file.path(path, filename), plot = p, width = 10, height = 8)
```

# SAVE POINT

```{r}
saveRDS(B_ALL_CAR.Object.All_Pools_filtered_no_t.rerun, file = paste0(save_point, "/B_ALL_CAR.Object.All_Pools_filtered_no_t.rerun.rds"))

# B_ALL_CAR.Object.All_Pools_filtered_no_t.rerun <- readRDS(paste0(save_point, "/B_ALL_CAR.Object.All_Pools_filtered_no_t.rerun.rds"))
```

## Task 6.3 Split UMAP for each sample

```{r}
Task6.3_UMAP_for_each_sample <- paste0(Task6_Combined_data_for_all_pools, "/Task6.3_UMAP_for_each_sample")
  
if(!exists(Task6.3_UMAP_for_each_sample)){
  dir.create(Task6.3_UMAP_for_each_sample)
}
```

```{r}
unique_labels <- unique(B_ALL_CAR.Object.All_Pools_filtered_no_t.rerun@meta.data$new_labels)

# Store plot objects in a list
plot_list <- list()

for (label in unique_labels) {
  # Extract data for plotting
  data <- FetchData(B_ALL_CAR.Object.All_Pools_filtered_no_t.rerun, vars = c("umap_1", "umap_2", "new_labels"))

  # Define the highlight condition directly in the data frame
  data$highlight <- ifelse(data$new_labels == label, 'highlighted', 'other')

  # Start a ggplot
  p <- ggplot(data, aes(x = umap_1, y = umap_2)) +
    geom_point(data = data[data$highlight == "other", ], aes(color = highlight), alpha = 0.5, size = 0.2) +
    geom_point(data = data[data$highlight == "highlighted", ], aes(color = highlight), size = 0.2) +
    scale_color_manual(values = c("other" = "grey", "highlighted" = "red")) +
    ggtitle(paste("UMAP Plot for", label)) +
    theme_minimal()

  pdf_filename <- paste0(Task6.3_UMAP_for_each_sample, "/UMAP_highlight_", label, ".pdf")
  
  pdf(pdf_filename, width = 8, height = 6)
  print(p)
  dev.off()
  
  plot_list[[label]] <- p
}

# Assuming 4x6 grid for 23 plots
combined_plot <- wrap_plots(plot_list, ncol = 4)
ggsave(filename = paste0(Task6.3_UMAP_for_each_sample, "/combined_UMAP.pdf"), 
       plot = combined_plot, width = 30, height = 20)
```

## Task 6.4 SLC27A2 Violin plot for each sample

```{r}
sample_order <- c(
  "WT_WT_Mock_48", "WT_WT_Mock_72", "WT_WT_CAR_48", "WT_WT_CAR_72", 
  "WT_KO_Mock_48", "WT_KO_Mock_72", "WT_KO_CAR_48", "WT_KO_CAR_72",
  "KO_WT_Mock_48", "KO_WT_Mock_72", "KO_WT_CAR_48", "KO_WT_CAR_72",
  "KO_KO_Mock_48", "KO_KO_Mock_72", "KO_KO_CAR_48", "KO_KO_CAR_72",
  "Pool7_PDX1", "Pool7_PDX3", "Pool7_PDX4", "Pool7_PDX5",
  "Pool8_PDX8", "Pool8_PDX9", "Pool8_PDX10"
  
)

slc27a2_data <- FetchData(
  B_ALL_CAR.Object.All_Pools_filtered_no_t.rerun, 
  vars = "SLC27A2"
)
slc27a2_data$new_labels <- B_ALL_CAR.Object.All_Pools_filtered_no_t.rerun@meta.data$new_labels

filtered_data <- slc27a2_data[slc27a2_data$SLC27A2 > 0, ]

filtered_data$new_labels <- factor(
  filtered_data$new_labels, 
  levels = sample_order
)
```

```{r}
# Statistical Smoothing: Violin plots use kernel density estimation (KDE) to estimate the distribution of the data. KDE can sometimes extend slightly beyond the actual range of the data, particularly when the kernel's bandwidth is not optimally adjusted for the data distribution. This could cause the appearance of negative values in plots even if the data itself doesn't contain any negatives.
# You can use geom_violin(trim = TRUE) to adjust.

p <- ggplot(filtered_data,
            aes(x = new_labels, y = SLC27A2, fill = as.factor((as.integer(new_labels) - 1) %/% 2))) + # Color groups by pairing every two samples
    geom_violin(trim = TRUE) +
    # geom_jitter(width = 0.2, size = 0.4, alpha = 0.4, color = "black") +
    stat_summary(fun = mean, geom = "errorbar", width = 0.2, 
                 color = "black", size = 0.5, linetype = "solid",
                 aes(ymin = ..y.., ymax = ..y..)) + 
    scale_fill_brewer(palette = "Paired") +
    theme_minimal() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1),
          legend.position = "none") +
    labs(title = paste("Expression of SLC27A2"),
         x = "Sample Group",
         y = "Expression Level")

p

pdf_filename <- paste0(Task6_Combined_data_for_all_pools, "/Task6.4_SLC27A2_violin_plot.pdf")
ggsave(filename = pdf_filename, plot = p, width = 14, height = 8)
```

# 7. Combine integrated scRNAseq

```{r}
Task7_Combined_integrated_data_all <- paste0(folder.name, "/Task7_Combined_integrated_data_all")
  
if(!exists(Task7_Combined_integrated_data_all)){
  dir.create(Task7_Combined_integrated_data_all)
}
```

## Task 7.1 Combine Integrated scRNAseq

```{r}
Task7.1_Combined_integrated_UMAP <- paste0(Task7_Combined_integrated_data_all, "/Task7.1_Combined_integrated_UMAP")
  
if(!exists(Task7.1_Combined_integrated_UMAP)){
  dir.create(Task7.1_Combined_integrated_UMAP)
}
```

```{r}
Combined.Object <- readRDS("/Users/tian/Desktop/Project_CU/2023_10_19_Witkowski_Integrated_scRNAseq_B-ALL_diagnosis_relapse/2024_05_31_Github_scFEA/SAVE_POINT/Combined.Object_with_reduction.rds")

# Combined.Object <- readRDS("/Users/tian/Desktop/Project_CU/2023_10_19_Witkowski_Integrated_scRNAseq_B-ALL_diagnosis_relapse/2024_05_31_Github_scFEA/SAVE_POINT/Combined.Object_only_Diagnosis_Relpase.rds")
```

```{r}
B_ALL_CAR.Object.All_Pools_filtered_no_t.rerun <- readRDS(paste0(save_point, "/B_ALL_CAR.Object.All_Pools_filtered_no_t.rerun.rds"))
B_ALL_CAR_697 <- B_ALL_CAR.Object.All_Pools_filtered_no_t.rerun
```

```{r}
### Harmonize Metadata Columns

B_ALL_CAR_697_colnames <- colnames(B_ALL_CAR_697@meta.data)
B_ALL_CAR_697_colnames
```

```{r}
Combined.Object_colnames <- colnames(Combined.Object@meta.data)
Combined.Object_colnames
```

```{r}
selected_colnames <- B_ALL_CAR_697_colnames[c(1, 2, 3, 4)]
```

```{r}
# Match Combined.Object_colnames metadata to B_ALL_CAR_697
# drop = FALSE keeps the output as a data frame not a vector
Combined.Object@meta.data <- Combined.Object@meta.data[, selected_colnames, drop = FALSE]
```

```{r}
B_ALL_CAR_697@meta.data <- B_ALL_CAR_697@meta.data[, selected_colnames, drop = FALSE]
```

```{r}
###Ensure Same Gene Set


# Find common genes
common_genes <- intersect(rownames(Combined.Object), rownames(B_ALL_CAR_697))

# Subset both Seurat objects to common genes
Combined.Object.subset.object <- subset(Combined.Object, features = common_genes)
B_ALL_CAR_697.subset.object <- subset(B_ALL_CAR_697, features = common_genes)
Combined.Object.subset.object@meta.data
```

```{r}
# Merge the two Seurat objects
final.Combined.Object <- merge(Combined.Object.subset.object, y = B_ALL_CAR_697.subset.object)
final.Combined.Object@meta.data
```

# SAVE POINT

```{r}
# saveRDS(final.Combined.Object, file = paste0(save_point, "/final.Combined.Object.rds"))
```

```{r}
final.Combined.Object@assays
# rownames(final.Combined.Object@assays[["RNA"]])
```

```{r}
final.Combined.Object@meta.data
```

```{r}
# Add Metadata
# Compute Num of gene per UMI

final.Combined.Object$log10GenePerUMI = log10(final.Combined.Object$nFeature_RNA) / log10(final.Combined.Object$nCount_RNA)
```

```{r}
# Compute Percent mito ratio

final.Combined.Object$mitoPct = PercentageFeatureSet(final.Combined.Object, pattern = "^MT-")
final.Combined.Object$mitoRatio = final.Combined.Object@meta.data$mitoPct / 100
```

```{r}
final.Combined.Object@meta.data
table(Combined.Object@meta.data$new_labels)
# View(final.Combined.Object@meta.data)
```

## Task 7.1.1 PCA and RunUMAP

```{r}
# Use standard normalization

DefaultAssay(final.Combined.Object) <- 'RNA'
final.Combined.Object <- NormalizeData(final.Combined.Object) %>% 
  # FindVariableFeatures() can find 'variable features', genes that exhibit high variability in expression levels across different cells
  FindVariableFeatures() %>% 
  ScaleData() %>% 
  RunPCA()
```

```{r}
# Determine percent of variation associated with each PC
pct <- final.Combined.Object[["pca"]]@stdev / sum(final.Combined.Object[["pca"]]@stdev) * 100
# pct

# Calculate cumulative percents for each PC
cumu <- cumsum(pct)
# cumu

# Determine which PC exhibits cumulative percent greater than 90% and % variation associated with the PC as less than 5
co1 <- which(cumu > 90 & pct < 5)[1]
co1
```

```{r}
# Identifies the PC where the percent change in variation between consecutive PCs is less than 0.1%
co2 <- sort(which((pct[1:length(pct) - 1] - pct[2:length(pct)]) > 0.1), decreasing = T)[1] + 1
co2
```

```{r}
# Choose the minimum of these two metrics as the PCs covering the majority of the variation in the data.
pcs <- min(co1, co2)
pcs
```

```{r}
plot_df <- data.frame(pct = pct,
                      cumu = cumu,
                      rank = 1:length(pct))

plot_df

ggplot(plot_df, aes(cumu, pct, label = rank, color = rank > pcs)) +
  geom_text() +
  # geom_vline(xintercept = 75, color = "grey") +
  # geom_hline(yintercept = min(pct[pct > 5]), color = "grey") +
  theme_bw()

```

```{r}
# Run Harmony to correct for batch effects in the PCA space (default - So must have PCA computed)
final.Combined.Object <- RunHarmony(final.Combined.Object, group.by.vars = "new_labels")
```

```{r}
# Default resolution: 0.8
final.Combined.Object <- final.Combined.Object %>%
  FindNeighbors(., dims = 1:pcs) %>%
  # Enable method = "igraph" to avoid casting large data to a dense matrix.
  FindClusters(., method = "igraph") %>%
  RunUMAP(.,
          dims = 1:40,
          # dims = 1:pcs,
          reduction = "harmony",
          n.components = 3L)
``` 

```{r}
head(final.Combined.Object@meta.data)
```

# SAVE POINT

```{r}
# saveRDS(final.Combined.Object, file = paste0(save_point, "/final.Combined.Object_with_reductions.rds"))
```

### Task 7.1.2 UMAP Plot

```{r}
final.Combined.Object@meta.data %>%
    dplyr::count(new_labels)
```

```{r}
num_unique_labels <- final.Combined.Object@meta.data %>%
    summarize(num_labels = n_distinct(new_labels)) %>%
    pull(num_labels)

print(num_unique_labels)
```

```{r}
# Task 2.2.3.1 Generate Distinct Colors

n <- num_unique_labels
qual_col_pals = brewer.pal.info[brewer.pal.info$category == 'qual',]
color = unlist(mapply(brewer.pal, qual_col_pals$maxcolors, rownames(qual_col_pals)))

# color = grDevices::colors()[grep('gr(a|e)y', grDevices::colors(), invert = T)]
# pie(rep(1,num_unique_labels), col=sample(color, num_unique_labels))

sample_colors=sample(color, num_unique_labels)
sample_labels <- levels(as.factor(final.Combined.Object@meta.data$new_labels))
sample_colors <- setNames(sample_colors, sample_labels)
```

```{r}
#### Task 2.2.3.2 2D Plot -- new_labels 

set.seed(123)  # Set a seed for reproducibility

plot <- dittoDimPlot(final.Combined.Object,
             var = "new_labels",
             color.panel = sample_colors,  # Use our custom colors
             size = 0.4,
             # legend.show = FALSE,
             legend.size = 5,
             do.label = TRUE,
             opacity = 0.5,
             labels.size = 1.5,
             reduction.use = "umap",
             xlab = "UMAP 1",
             ylab = "UMAP 2",
             main = "UMAP for All Samples"
             )

# Modify the plot to change legend text size
plot <- plot + theme(legend.position = "bottom",
                     legend.text = element_text(size = 8),
                     legend.spacing.x = unit(1, 'cm'), # Adjust spacing
                     legend.spacing.y = unit(1, 'cm')) 

ggsave(filename = paste0(Task7.1_Combined_integrated_UMAP, "/2D_UMAP_with_new_labels.pdf"), 
       plot = plot, 
       width = 12,  
       height = 10)
```

```{r}
#### Task 2.2.3.3 Interactive Plot -- new_labels

# Extract UMAP data
umap_data <- Embeddings(final.Combined.Object, reduction = "umap")
# Extract metadata for hover information
# umap_metadata <- FetchData(final.Combined.Object, vars = c("new_labels", "predicted.id"))
umap_metadata <- FetchData(final.Combined.Object, vars = "new_labels")
# Combine UMAP data with metadata
umap_plot_data <- cbind(umap_data, umap_metadata)

umap_plot_data$new_labels <- as.factor(umap_plot_data$new_labels)
# umap_plot_data$predicted.id <- as.factor(umap_plot_data$predicted.id)
umap_plot_data_df <- as.data.frame(umap_plot_data)
```

```{r}
# Create an interactive plot
fig <- plot_ly(umap_plot_data_df, 
               x = ~umap_1, 
               y = ~umap_2, 
               type = 'scatter', 
               mode = 'markers',
               color = ~new_labels,
               colors = sample_colors,
               marker = list(size = 3, opacity = 0.5),               
               text = ~paste("Label:", new_labels),
               hoverinfo = 'text')

# Customize the layout
fig <- fig %>% layout(title = 'Interactive UMAP Plot',
                      xaxis = list(title = 'UMAP 1'),
                      yaxis = list(title = 'UMAP 2'),
                      legend = list(font = list(size = 12)))

saveWidget(fig, file = paste0(Task7.1_Combined_integrated_UMAP, "/Interactive_UMAP_with_new_labels.html"))
```

```{r}
# Easy method:

set.seed(123)
p <- DimPlot(final.Combined.Object, reduction = "umap", group.by =  "new_labels", label = TRUE, repel = TRUE, label.size = 3) 
p <- p + theme(legend.text = element_text(size = 6))
p
# filename <- "final_UMAP.pdf"
# path <- paste0(folder.name)
# ggsave(filename = file.path(path, filename), plot = p, width = 10, height = 8)
```

## Task 7.2 Split UMAP for each sample

```{r}
Task7.2_UMAP_for_each_sample <- paste0(Task7_Combined_integrated_data_all, "/Task7.2_UMAP_for_each_sample")
  
if(!exists(Task7.2_UMAP_for_each_sample)){
  dir.create(Task7.2_UMAP_for_each_sample)
}
```

```{r}
unique_labels <- unique(final.Combined.Object@meta.data$new_labels)

# Store plot objects in a list
# plot_list <- list()

for (label in unique_labels) {
  # Extract data for plotting
  data <- FetchData(final.Combined.Object, vars = c("umap_1", "umap_2", "new_labels"))

  # Define the highlight condition directly in the data frame
  data$highlight <- ifelse(data$new_labels == label, 'highlighted', 'other')

  # Start a ggplot
  p <- ggplot(data, aes(x = umap_1, y = umap_2)) +
    geom_point(data = data[data$highlight == "other", ], aes(color = highlight), alpha = 0.5, size = 0.2) +
    geom_point(data = data[data$highlight == "highlighted", ], aes(color = highlight), size = 0.2) +
    scale_color_manual(values = c("other" = "grey", "highlighted" = "red")) +
    ggtitle(paste("UMAP Plot for", label)) +
    theme_minimal()

  pdf_filename <- paste0(Task7.2_UMAP_for_each_sample, "/UMAP_highlight_", label, ".pdf")
  
  pdf(pdf_filename, width = 8, height = 6)
  print(p)
  dev.off()
  
  plot_list[[label]] <- p
}

# Assuming 10x6 grid for 59 plots
# combined_plot <- wrap_plots(plot_list, ncol = 10)
# ggsave(filename = paste0(Task7.2_UMAP_for_each_sample, "/combined_UMAP.pdf"), 
       # plot = combined_plot, width = 90, height = 60, limitsize = FALSE)
```

# End